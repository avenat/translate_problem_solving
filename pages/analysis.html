---
layout: page
title: "Анализ алгоритмов"
description: ""
---
{% include JB/setup %}
<h1>Анализ алгоритмов</h1>

<h2>Цели</h2>
<ul>
	<li>Понять, почему так важен анализ алгоритмов.</li>
	<li>Быть готовыми использовать нотацию большого "О" для описания времени выполнения.</li>
	<li>Понять большое "О" времени выполнения наиболее распространённых операций над списками и словарями в Python.</li>
	<li>Понять, как реализация данных в Python влияет на анализ алгоритмов.</li>
	<li>Понять, как сравнивать простые программы на Python.</li>
</ul>

<h2>Что такое "анализ алгоритмов"?</h2>
<p>Студенты-первокурсники ИТ-специальностей очень часто сравнивают свои программы с программами других. Так же вы могли замечать, что быть похожими друг на друга - общее свойство многих компьютерных программ, особенно простых. В связи с этим возникает интересный вопрос: если две программы решают одну и ту же задачу, но выглядят по разному, то как понять, что одна из них лучше?</p>

<p>Чтобы ответить на него, нам нужно вспомнить о важном различии между собственно программой и алгоритмом, который она воплощает. Как мы уже говорили в главе 1, алгоритм - это универсальная пошаговая инструкция для решения задачи. Это метод поиска ответа для любого частного случая проблемы, который при заданных входных значениях выдаёт требуемый результат. С другой стороны, программа - это то, как алгоритм переложен на некий язык программирования. Может быть множество программ, реализующих один и тот же алгоритм, в зависимости от программиста и языка, который был использован.</p>

<p>Для дальнейшего исследования этого различия рассмотрим функцию из <i>ActiveCode 1</i>. Она решает всем знакомую задачу вычисления суммы первых <i>n</i> целых чисел. Алгоритм использует идею переменной-аккумулятора, которая инициализируется нулём. В процессе решения перебираются <i>n</i> чисел, каждое из которых прибавляется к аккумулятору.</p>

<p align="center"><b>Active Code: 1</b> Суммирование первых n целых чисел</p>

<p>А сейчас посмотрите на функцию в <i>ActiveCode 2</i>. На первый взгляд она может показаться странной, но при более близком рассмотрении вы увидите, что она делает в точности то же самое, что и предыдущая. Причина, по которой это не очевидно, - в плохом качестве кода. Здесь мы не используем понятные имена для идетификаторов, чтобы повысить читабельность, и делаем избыточное присваивание на шаге аккумуляции, что совершенно не является необходимым.</p>

<p align="center"><b>Active Code: 2</b> Ещё одно суммирование первых n целых чисел</p>

<p>В ранее озвученном вопросе мы спрашивали: как понять, что одна функция лучше другой? Ответ будет зависеть от выбранных критериев. Функция {% highlight Python %}sumOf{% endhighlight %} естественно лучше, чем {% highlight Python %}foo{% endhighlight %}, если вы беспокоитесь о читабельности. На самом деле, вы, возможно, видели множество подобных примеров в вводных курсах по программированию, поскольку одной из их целей является желание помочь вам научиться писать программы, которые легко читать и понимать. Однако, сейчас мы заинтересованы в том, чтобы охарактеризовывать алгоритм сам по себе (хотя надеемся, что вы продолжите бороться за читаемый и хорошо понимаемый код).</p>

<p>Анализ алгоритмов основывается на их сравнении по затрачиваемому каждым объёму вычислительных ресурсов. Мы хотим быть способными взять два алгоритма и сказать, что один из них лучше другого, потому что более эффективно использует имеющиеся ресурсы или, возможно, ему их просто меньше требуется. С этой точки зрения две функции выше выглядят очень похожими. Они обе используют один и тот же алгоритм для решения задачи суммирования.</p>

<p>На данный момент важно задуматься над тем, что же мы подразумеваем под "вычислительными ресурсами". Существует два различных подхода к этому вопросу. Первый рассматривает объём дискового пространства или памяти, требуемый алгоритму для решения. Эта величина обычно зависит от конкретного варианта задачи. Однако, часто встречаются алгоритмы, имеющие специфические требования к объёму, и в таких случаях мы будем очень аккуратно подходить к объяснению вариантов.</p>

<p>Альтернативой требованиям такого рода является анализ и сравнение алгоритмов по времени, которое им необходимо для вычислений. Эту величину иногда называют "временем выполнения" алгоритма. Одним из способов измерить время выполнения функции {% highlight Python %}sumOfN{% endhighlight %} является проведение сравнительного анализа. Он подразумевает, что мы засечём реальное время, требуемое программе на вычисление результата. В Python мы можем проделать эту операцию, отметив время начала и время окончания работы программы относительно используемой нами системы. В модуле {% highlight Python %}time{% endhighlight %} есть функция {% highlight Python %}time{% endhighlight %}, которая возвращает текущее системное время в секундах, прошедшее с некоторого произвольного начального момента. Вызвав эту функцию дважды - в начале и в конце, - и затем посчитав разницу, мы получим точное количество секунд (дробное в большинстве случаев), затраченных на выполнение.</p>

<b>Листинг 1</b>
{% highlight Python %}
import time

def sumOfN2(n):
   start = time.time()

   theSum = 0
   for i in range(1,n+1):
      theSum = theSum + i

   end = time.time()

   return theSum,end-start
{% endhighlight %}

<p><i>Листинг 1</i> демонстрирует оригинальную функцию {% highlight Python %}sumOfN{% endhighlight %} с вызовами времени, встроенными до и после суммирования. Она возвращает кортеж, состоящий из результата и количества затраченного на вычисления времени (в секундах). Если мы выполним пять вызовов функции, в каждом из которых будет вычисляться сумма первых 10 000 целых чисел, то мы получим следующее:</p>

{% highlight Python %}
>>>for i in range(5):
       print("Sum is %d required %10.7f seconds"%sumOfN(10000))
Sum is 50005000 required  0.0018950 seconds
Sum is 50005000 required  0.0018620 seconds
Sum is 50005000 required  0.0019171 seconds
Sum is 50005000 required  0.0019162 seconds
Sum is 50005000 required  0.0019360 seconds
{% endhighlight %}

<p>Мы выяснили, что результат имеет хорошую повторяемость и что на выполнение кода затрачивается примерно 0,0019 секунд. А что будет, если мы сложим первые 100 000 целых?</p>

{% highlight Python %}
>>>for i in range(5):
       print("Sum is %d required %10.7f seconds"%sumOfN(100000))
Sum is 5000050000 required  0.0199420 seconds
Sum is 5000050000 required  0.0180972 seconds
Sum is 5000050000 required  0.0194821 seconds
Sum is 5000050000 required  0.0178988 seconds
Sum is 5000050000 required  0.0188949 seconds
>>>
{% endhighlight %}

<p>Временн<b>ы</b>е значения для каждого запуска вновь лежат близко друг к другу, но величина их возрастает - примерно в десять раз. Для {% highlight Python %}n{% endhighlight %}, равной 1 000 000 мы получим:</p>

{% highlight Python %}
>>>for i in range(5):
       print("Sum is %d required %10.7f seconds"%sumOfN(1000000))
Sum is 500000500000 required  0.1948988 seconds
Sum is 500000500000 required  0.1850290 seconds
Sum is 500000500000 required  0.1809771 seconds
Sum is 500000500000 required  0.1729250 seconds
Sum is 500000500000 required  0.1646299 seconds
>>>
{% endhighlight %}

<p>Среднее значение вновь выросло примерно в десять раз по сравнению с предыдущим.</p>

<p>А теперь рассмотрим <i>ActiveCode 3</i>, демонстрирующий другой способ решения задачи суммирования. Эта функция, {% highlight Python %}sumOfN3{% endhighlight %} использует преимущество замкнутой формулы <span  class="colortext">вставить формулу</span> для вычисления суммы первых {% highlight Python %}n{% endhighlight %} целых без выполнения итераций.</p>

<p align="center"><b>Active Code: 3</b> Суммирование без итераций</p>

<p>Если мы проведём аналогичные контрольные замеры для {% highlight Python %}sumOfN3{% endhighlight %}, используя пять различных значений {% highlight Python %}n{% endhighlight %} (10 000, 100 000, 1 000 000, 10 000 000 и 100 000 000), то результат будет следующим:</p>

{% highlight Python %}
Sum is 50005000 required 0.00000095 seconds
Sum is 5000050000 required 0.00000191 seconds
Sum is 500000500000 required 0.00000095 seconds
Sum is 50000005000000 required 0.00000095 seconds
Sum is 5000000050000000 required 0.00000119 seconds
{% endhighlight %}

<p>Есть два важных момента, связанных с полученными выходными данными, на которые стоит обратить внимание. Первый - затраченное время намного меньше, чем в любом из предыдущих примеров. И второй - все временн<b>ы</b>е величины очень близки друг к другу, вне зависимости от значения {% highlight Python %}n{% endhighlight %}. Похоже, что {% highlight Python %}sumOfN3{% endhighlight %} абсолютно всё равно, сколько чисел ей требуется сложить.</p>

<p>Но что этот тест говорит нам в действительности? Интуитивно мы догадываемся, что итеративное решение будет выполнять больше работы из-за повторения некоего набора программных шагов. Это, скорее всего, причина, по которой оно занимает больше времени. Так же похоже, что время, требуемое итеративному решению, возрастает при увеличении значения {% highlight Python %}n{% endhighlight %}. Тут, однако, возникает проблема. Если мы запустим одну и ту же функцию на разных компьютерах или используем различные языки программирования, то вполне возможно, что получим разные результаты. Вычисление {% highlight Python %}sumOfN3{% endhighlight %} займёт тем больше времени, чем старее компьютер.</p>

<p>Нам нужен более хороший способ характеризовать алгоритмы относительно времени выполнения. Тестовая методика вычисляет фактическое время выполнения. Она не предоставляет нам действительного полезного результата измерений, поскольку зависит от конкретной машины, программы, времени дня, компилятора и языка программирования. Вместо этого мы хотели бы иметь характеристику, не зависящую от программы или компьютера. Такая величина была бы полезна для оценки алгоритма самого по себе, и её можно было бы использовать для сравнения алгоритмов в различных реалиазациях.</p>

<h3>Нотация большое "О"</h3>
<p>При попытке охарактеризовать эффективность алгоритма в терминах времени выполнения независимо от конкретной программы или компьютера, очень важно оценить количество операций, или шагов, которые потребуются алгоритму. Если каждую из них принять за базовую единицу вычисления, то время выполнения может быть выражено, как количество шагов, требуемых для решения задачи. Принятие решение о том, что же является таким базовым блоком, может оказаться непростым и зависящим от того, как алгоритм реализован.</p>

<p>Хорошей элементарной единицей вычисления для сравнения суммирующих алгоритмов, демонстрированных выше, может послужить количество операций присваивания, используемых при подсчёте суммы. В функции {% highlight Python %}sumOfN{% endhighlight %} оно только одно (<b><i>theSum = 0</i></b>) плюс значение <i>n</i> (сколько раз мы вычисляем <b><i>theSum = theSum + i</i></b>). Мы можем обозначить эту величину (назовём её T) как функцию, где <b><i>T(n)=1+n</i></b>. Параметр <i>n</i> часто называют "размером задания", так что мы можем прочитать это как "T(n) - это время, необходимое для решения задачи, размером n, за 1+n шагов."</p>

<p>В представленных выше функциях суммирования для обозначения размера задачи имеет смысл использовать количество слагаемых. Так мы сможем сказать, что суммирование первых 100 000 целых - задание большее, чем суммирование 1 000. Поэтому утверждение, что время, требуемое для решение первого случая, будет больше, чем для второго, выглядит разумным. Таким образом, наша цель - показать, как время работы алгоритма изменяется в зависимости от размера задачи.</p>

<p>Учёные-информатики в данной технике анализа предпочитают идти на один шаг дальше. Получается, что точное количество операций не так важно, как определение доминирующей части функции <b><i>T(n)</i></b>. Другими словами, когда задание становится больше, некая часть функции <b><i>T(n)</i></b>, как правило, перекрывает всё остальное. Эта доминирующая часть в итоге и используется при сравнении. Функция <b>порядка величины</b> описывает ту часть <b><i>T(n)</i></b>, которая при росте <i>n</i> возрастает сильнее. Порядок величины часто называют <b>нотацией большое "О"</b> (от <i>order</i> - порядок) и записывают как <b><i>O(f(n))</i></b>. Она даёт целесообразное приближение к фактическому числу шагов в вычислении. Функция <b><i>f(n)</i></b> является простым представлением доминирующей части оригинальной <b><i>T(n)</i></b>.</p>

<p>В примере выше <b><i>T(n) = 1 + n</i></b>. Чем больше становится <i>n</i>, тем менее значимой для конечного результата является константа 1. При поиске приближения для <b><i>T(n)</i></b> мы можем отбросить единицу и просто сказать, что время выпонения равно <b><i>O(n)</i></b>. Важно отметить, что 1 безусловно важна для <b><i>T(n)</i></b>. Однако, при росте <i>n</i> наше приближение и без неё останется не менее точным.</p>

<p>Ещё один пример: предположим, что для некоего алгоритма точное число шагов <b><i>T(n) = 5n<sup>2</sup> + 27n + 1005</i></b>. При малых <i>n</i> (скажем, 1 или 2) константа 1005 выглядит доминирующей частью функции. Но с ростом <i>n</i> превалирующим становится слагаемое <b><i>n<sup>2</sup></i></b>. Фактически, когда <i>n</i> действительно велико, то два других слагаемых перестают играть значимую роль в определении конечного результата. То есть при аппроксимации <b><i>T(n)</i></b> с увеличением <i>n</i> мы можем игнорировать прочие слагаемые и сфокусироваться только на <b><i>5n<sup>2</sup></i></b>. Более того, коэффициент <b>5</b> с возрастанием <i>n</i> тоже теряет значимость. Так что можно сказать, что функция <b><i>T(n)</i></b> имеет порядок величины <b><i>f(n)=n<sup>2</sup></i></b>, или просто <b><i>O(n<sup>2</sup>)</i></b></p>

<p>Хотя мы и не видим этого в примере с суммированием, иногда производительность алгоритма зависит от точных значений данных больше, чем от размера задачи. Для алгоритмов такого рода необходимо характеризовать их эффективность с точки зрения <b>наилучшего, наихудшего</b> или <b>усреднённого случая</b>. Производительность для худшего случая относится к определённому набору данных, на котором алгоритм работает особенно плохо. С другой стороны, другие последовательности данных для точно такого же алгоритма будут иметь необычайно хорошую производительность, так что в большинстве случаев алгоритм имеет производительность где-то по середине между этими двумя экстремумами (усреднённый случай). Для учёных-информатиков важно понимать данные различия, чтобы на впасть в заблуждение при рассмотрении единственного конкретного случая.</p>

<p>Некоторые очень распространённые функции порядка величины в процессе изучения алгоритмов будут попадаться вам снова и снова. Все они представлены в <i>таблице 1</i>. Для того, чтобы оперелить, какая из них является доминирующей частью произвольной <b><i>T(n)</i></b>, мы должны видеть, как они соотносятся друг с другом при возрастании <i>n</i></p>.

<table border="1" align="center">
  <caption><b>Таблица 1: Наиболее рапространённые функции большого "О"</b></caption>
  <tr>
    <td><b>f(n)</b></td><td><b>Название</b></td>
  </tr>
  <tr>
    <td>1</td><td>Константная</td>
  </tr>
  <tr>
    <td>log <i>n</i></td><td>Логарифмическая</td>
  </tr>
  <tr>
    <td><i>n</i></td><td>Линейная</td>
  </tr>
  <tr>
    <td><i>n</i> log <i>n</i></td><td>Линейно-логарифмическая</td>
  </tr>
  <tr>
    <td><i>n<sup>2</sup></i></td><td>Квадратичная</td>
  </tr>
  <tr>
    <td><i>n<sup>3</sup></i></td><td>Кубическая</td>
  </tr>
  <tr>
    <td><i>2<sup>n</sup></i></td><td>Экспоненциальная</td>
  </tr>
</table>

<p>На <i>рисунке 1</i> показаны графики функций из <i>таблицы 1</i>. Обратите внимание, что при малых <i>n</i> их нелегко отличить друг от друга и сложно сказать, какая является доминирующей. Однако, как только <i>n</i> вырастает, появляется определённая зависимость, и легко увидеть, как функции соотносятся друг с другом.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/newplot.png"></p>
<p align="center">Рисунок 1: Графики распространённых функций большого "О"</p>

<p>В качестве заключительного примера предположим, что у нас есть фрагмент кода на Python, показанный в <i>Листинге 2</i>. Несмотря на то, что на самом деле эта программа ничего не делает, полезно будет посмотреть, как мы можем взять существующий код и проанализировать его производительность.</p>

<b>Листинг 2</b>
{% highlight Python %} 
a=5
b=6
c=10
for i in range(n):
   for j in range(n):
      x = i * i
      y = j * j
      z = i * j
for k in range(n):
   w = a*k + 45
   v = b*b
d = 33
{% endhighlight %}

<p>Число операций присваивания равно сумме четырёх слагаемых. Первое - константа 3, представляющая три присваивания в начале фрагмента. Второе - <b><i>3n<sup>2</sup></i></b>, поскольку ещё три присваивания выполняются <b><i>n<sup>2</sup></i></b> раз внутри вложенного цикла. Третье - <b><i>2n</i></b> - два присваивания, повторяющиеся <i>n</i> раз. И, наконец, четвёртое слагаемое - константа 1, представляющая оператор присваивания в последней строке. Всё вместе это даёт <b><i>T(n) = 3 + 3n<sup>2</sup> + 2n + 1 = 3n<sup>2</sup> + 2n + 4</i></b>. Глядя на степени, мы легко можем заметить, что доминантой будет <b><i>n<sup>2</sup></i></b>, и, следовательно, данный фрагмент кода имеет <b><i>O(n<sup>2</sup>)</i></b>. Обратите внимание, что прочие слагаемые (так же, как и коэффициенты) можно проигнорировать при возрастании <i>n</i>.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/newplot2.png"></p>
<p align="center">Рисунок 2: Сравнение <b><i>T(n)</i></b> с распространёнными функциями большого "О"</p>

<p>На <i>рисунке 2</i> показаны графики нескольких распространённых функций большого "О" в сравнении с обсуждаемой <b><i>T(n)</i></b>. Обратите внимание, что изначально <b><i>T(n)</i></b> больше, чем кубическая функция, но с ростом <i>n</i> последняя быстро берёт верх. Так же легко увидеть, что <b><i>T(n)</i></b> с ростом <b><i>n</i></b> следует за квадратичной функцией.</p>

<b>Самопроверка</b>
<p>Напишите на Python две функции для поиска минимального значения в списке. Первая из них должна сравнивать каждое число со всеми другими значениями в списке. <b><i>O(n<sup>2</sup>)</i></b>. Вторая функция должна быть линейной с <b><i>O(n)</i></b></p>

<h3>Пример с распознаванием анаграммы</h3>
<p>Хорошим примером для демонстрации алгоритмов с разным порядком величины является классическая задача распознавания в слове анаграммы. Одна строка будет анаграммой другой, если вторая получается простой перестановкой букв первой. Например, {% highlight Python %}'heart'{% endhighlight %} и {% highlight Python %}'earth'{% endhighlight %} - это анаграммы. Как и {% highlight Python %}'python'{% endhighlight %} и {% highlight Python %}'typhon'{% endhighlight %}. Для простоты будем полагать, что обе заданные строки имеют одинаковую длину и составлены из набора символов в 26 строчных букв. Нашей целью будет написать булеву функцию, принимающую две строки и возвращающую ответ - являются ли они анаграммами?</p>

<h4>Решение 1: Метки</h4>
<p>Наше первое решение задачи об анаграмме будет проверять, входит ли каждый из символов первой строки во вторую. Если все символы будут "отмечены", то строки являются анаграммами. "Пометка" символа будет происходить с помощью замены его на специальное значение Python {% highlight Python %}None{% endhighlight %}. Однако, поскольку строки в Python иммутабельны, то первым шагом обработки станет конвертирование второй строки в список. Каждый символ из первой строки может быть сверен с элементами списка и, если будет в нём обнаружен, отмечен оговоренной заменой. <i>ActiveCode 4</i> демонстрирует эту функцию.</p>

<p align="center"><b>Active Code: 4</b> Метки</p>

<p>При анализе алоритма нам стоит отметить, что каждый из <i>n</i> символов в {% highlight Python %}s1{% endhighlight %} вызовет цикл по <i>n</i> символам списка, полученного из {% highlight Python %}s2{% endhighlight %}. Каждая из <i>n</i> позиций списка будет посещена единождыс целью проверки на соответствие {% highlight Python %}s1{% endhighlight %}. Количество таких посещений будет выражено через сумму целых чисел от 1 до <i>n</i>. Ранее мы уже говорили, что это может быть записано как</p>

<span  class="colortext">вставить формулу</span>

<p>С увеличением <b><i>n</i></b> слагаемое <b><i>n<sup>2</sup></i></b> начнёт доминировать, так что <b><i>n</i></b> и <b><i>1/2</i></b> можно проигнорировать. Таким образом, решение является <b><i>O(n<sup>2</sup>)</i></b>.</p>

<h4>Решение 2: Сортируй и сравнивай</h4>

<p>Следующее решение задачи об анаграмме будет использовать тот факт, что даже если {% highlight Python %}s1{% endhighlight %} и {% highlight Python %}s2{% endhighlight %} различны, то они будут анаграммами только если состоят из одинаковых символов. Следовательно, отсортировав каждую строку в алфавитном порядке от <i>a</i> до <i>z</i>, мы получим одинаковые строки (если, конечно, {% highlight Python %}s1{% endhighlight %} и {% highlight Python %}s2{% endhighlight %} - анаграммы). Это решение показано в <i>ActiveCode 5</i>. Опять же, в Python для списков, полученных в начале функции конвертацией каждой строки, мы можем использовать встроенный метод {% highlight Python %}sort{% endhighlight %}.</p>

<p align="center"><b>Active Code: 5</b> Сортируй и сравнивай</p>

<p>В первый момент вы можете подумать, что этот алгоритм имеет <b><i>O(n)</i></b>, поскольку у него есть всего одна простая итерация для сравнения <i>n</i> символов после сортировки. Однако, два вызова Python-метода {% highlight Python %}sort{% endhighlight %} не проходят бесследно. Как мы увидим в следующих главах, сортировка обычно имеет <b><i>O(n<sup>2</sup>)</i></b> или <b><i>O(n</i> log <i>n)</i></b>, так что эта операция доминирует над циклом. В итоге алгоритм будет иметь тот же порядок операций, что и сортировочный процесс.</p>

<h4>Решение 3: Полный перебор</h4>

<p>Техника <b>полного перебора</b> для решения задач обычно используется, когда все другие возможности уже исчерпаны. Для задачи определения анаграммы мы можем просто сгенерировать список всех возможных строк из символов {% highlight Python %}s1{% endhighlight %} и посмотреть, входит ли в него {% highlight Python %}s2{% endhighlight %}. Но в данном подходе есть одна закавыка: при генерации всех возможных строк из {% highlight Python %}s1{% endhighlight %} есть <i>n</i> возможных первых символов, <b><i>n</i> - 1</b> возможных вторых символов и так далее. Отсюда общее количество строк-кандидатов будет <b><i>n</i>*(<i>n</i>−1)*(<i>n</i>−2)*...*3*2*1</b>, что есть <b><i>n</i>!</b>. Несмотря на дублирование некоторых результатов, программа об этом заранее знать не может, поэтому всё равно сгенерирует <b><i>n</i>!</b> различных строк.</p>

<p>Решение <b><i>n</i>!</b> с увеличением <i>n</i>возрастает быстрее, чем даже <b>2<sup><i>n</i></sup></b>. Фактически, при длине {% highlight Python %}s1{% endhighlight %} в 20 символов мы получим <b>20!=2 432 902 008 176 640 000</b> возможных строк-кандидатов. Если мы будем обрабатывать одну вероятность каждую секунду, то на весь список уйдёт 77 146 816 596 лет. Похоже, это не самая светлая идея.</p>

<h4>Решение 4: Подсчитывай и сравнивай</h4>

<p>Наше последнее решения для задачи об анаграмме воспользуется преимуществом того факта, что любые две анаграммы имеют одинаковое количество букв <i>a</i>, <i>b</i> и так далее. Для того, чтобы решить, являются ли строки анаграммами, мы сначала подсчитаем, сколько раз в них встречается каждый символ. Поскольку возможных букв 26, то мы можем использовать список из 26 счётчиков - по одному на каждую. Всякий раз, когда мы встретим кокретную букву, мы увеличим соответствующий ей счётчик на единицу. Если в итоге оба списка счётчиков идетичны, то строки - анаграммы. Это решение показано в <i>ActiveCode 6</i>.</p>

<p align="center"><b>Active Code: 6</b> Подсчитывай и сравнивай</p>

<p>Решение вновь имеет некоторое количество циклов. Однако, в отличии от первого варианта, ни один из них не является вложенным. Два первых цикла, используемые для подсчёта символов, базируются на <i>n</i>. Третий цикл - сравнение двух списков счётчиков - всегда состоит из 26 итераций (поскольку строки состоят из 26 возможных элементов). Складывая всё вместе, получим <b>T(<i>n</i>)=2<i>n</i>+26</b> шагов, что является <b>O(<i>n</i>)</b>. Мы нашли алгоритм с линейным порядком величины для решения нашей задачи.</p>

<p>До того, как закончить с этим примером, стоит сказать несколько слов о требованиях к используемому пространству. Хотя последнее решение и работает за линейное время, оно достигает этого путём выделения дополнительных хранилищ для двух списков счётчиков. Другими словами, данный алгоритм приносит в жертву место, чтобы выиграть время.</p>

<p>Это распространённая ситуация. Очень часто вам придётся делать выбор между временем и пространством. В данном случае объём места был не существенен. Однако, если основополагающий алфавит будет иметь миллионы символов, то это вызовет большее беспокойство. При выборе алгоритма только от вас, как от учёных-информатиков, будет зависеть определение наилучшего использования вычислительных ресурсов, выделенных под конкретную задачу.</p>

<b>Самопроверка</b>
<p>Q-1: Каково "большое О" времени выполнения для следующего фрагмента кода?</p>
<p>Q-2: Каково "большое О" времени выполнения для следующего фрагмента кода?</p>
<p>Q-3: Каково "большое О" времени выполнения для следующего фрагмента кода?</p>

<h2>Производительность структур данных в Python</h2>

<p>Теперь, когда у вас есть общее представление о том, что же такое нотация большого "О" и в чём заключаются различия между разными функциями, наша цель в этом разделе - рассказать вам о производительности операций над списками и словарями в Python. Мы проведём несколько временн<b>ы</b>х экспериментов, чтобы продемонстрировать затраты и выгоды при использовании конкретных операций каждой из озвученных структур данных. Понимать, какова эффективность списков и словарей, очень важно для вас, потому что они являются строительными блоками, которые мы будем использовать при реализации других структур данных на протяжении оставшихся глав этой книги. В данном разделе мы не планируем объяснять, почему производительность такова, какова она есть. Позднее вы сами увидите возможные реализации списков и словарей, и то, как меняется их эфективность.</p>

<h3>Списки</h3>

<p>Разработчики Python имели широкий выбор при реализации списков как структуры данных. Каждое принятое ими решение оказывало влияние на скорость выполнения операций со списками. Чтобы не допустить промахов, они смотрели на то, для чего пользователи используют списки чаще всего, и  оптимизировали реализацию таким образом, чтобы наиболее распространённые операции совершались очень быстро. Конечно, они так же старались сделать быстрыми и менее используемые операции, но при поиске компромиссов производительность мало распространённых операций приносилась в жертву более распространённым.</p>

<p>Двумя наиболее часто используемыми операциями для списков являются индексация и присваивание на заданную позицию. Обе они занимают одинаковое время, вне зависимости от того, насколько велик список. Когда операции не зависят от размера задания (как названные выше), то говорят, что они имеют <b><i>O</i>(1)</b>.</p>

<p>Другой часто встречающейся программистской задачей является наращивание списка. Существует два способа продлить список. Вы можете исользовать метод {% highlight Python %}append{% endhighlight %} или оператор конкатенации. Первый имеет <b><i>O</i>(1)</b>, а второй - <b><i>O(k)</i></b>, где <i>k</i> - размер списка, который будет присоединён. Эта информация полезна для вас, поскольку помогает сделать ваши программы более эффективными, выбрав правильный инструмент для работы.</p>

<p>Давайте рассмотрим четыре разных способа сгенерировать список из {% highlight Python %}n{% endhighlight %} чисел, начинающийся с нуля. Сначала мы попробуем использовать цикл {% highlight Python %}for{% endhighlight %} и создадим список с помощью конкатенации. Затем воспользуемся методом {% highlight Python %}append{% endhighlight %}. Далее попытаемся создать список с помощью генератора списков. И, наконец, воспользуемся, возможно, самым очевидным способом - функцией {% highlight Python %}range{% endhighlight %}, обёрнутой в конструктор списка. <i>Листинг 3</i> показывает код для всех четырёх способов.</p>

<b>Листинг 3</b>
{% highlight Python %}
def test1():
    l = []
    for i in range(1000):
        l = l + [i]

def test2():
    l = []
    for i in range(1000):
        l.append(i)

def test3():
    l = [i for i in range(1000)]

def test4():
    l = list(range(1000))
{% endhighlight %}

<p>Для измерения времени, затрачиваемого каждой функцией, мы используем модуль Python {% highlight Python %}timeit{% endhighlight %}. Он был разработан с целью предоставить программистам на Python возможность делать кроссплатформенные синхронные измерения, запуская функции в согласованной среде и используя механизмы синхронизации, максимально схожие между собой для разных операционных систем.</p>

<p>Чтобы использовать {% highlight Python %}timeit{% endhighlight %}, вам нужно создать объект {% highlight Python %}Timer{% endhighlight %}, чьими параметрами являются две инструкции на Python. Первая - выражение Python, для которого вы хотите получить время выполнения; вторая - оператор, который будет выполнен единожды для "настройки" теста. Модуль {% highlight Python %}timeit{% endhighlight %} будет несколько раз замерять время, необходимое для заданной операции. По умолчанию он попытается запустить её один миллион раз. Когда это будет сделано, метод вернёт время как число с плавающей запятой, представляющее из себя количество потребовавшихся секунд. Однако, поскольку он вычислял операцию миллион раз, то вы можете прочитать результат, как количество микросекунд, затраченных на выполнение одного теста. Так же можно передать в {% highlight Python %}timeit{% endhighlight %} именованный параметр {% highlight Python %}number{% endhighlight %}, который позволит вам конкретизировать, сколько раз нужно запустить оператор. Следующий фрагмент кода показывает, как долго занимает запуск каждой тестовой функции тысячу раз.</p>

{% highlight Python %}
t1 = Timer("test1()", "from __main__ import test1")
print("concat ",t1.timeit(number=1000), "milliseconds")
t2 = Timer("test2()", "from __main__ import test2")
print("append ",t2.timeit(number=1000), "milliseconds")
t3 = Timer("test3()", "from __main__ import test3")
print("comprehension ",t3.timeit(number=1000), "milliseconds")
t4 = Timer("test4()", "from __main__ import test4")
print("list range ",t4.timeit(number=1000), "milliseconds")

concat  6.54352807999 milliseconds
append  0.306292057037 milliseconds
comprehension  0.147661924362 milliseconds
list range  0.0655000209808 milliseconds
{% endhighlight %}

<p>В эксперименте выше операторами, для которых мы замеряли время, были функции {% highlight Python %}test1(){% endhighlight %}, {% highlight Python %}test2(){% endhighlight %} и так далее. Оператор начальной настройки может показаться вам очень необычным, так что давайте разберём его детальнее. Возможно, вы хорошо знакомы с операторами {% highlight Python %}from{% endhighlight %} и {% highlight Python %}import{% endhighlight %}, но обычно их используют в начале файлов программ на Python. В нашем случае оператор {% highlight Python %}from __main__ import test1{% endhighlight %} импортирует функцию {% highlight Python %}test1{% endhighlight %} из пространства имён {% highlight Python %}__main__{% endhighlight %} в пространство имён, где {% highlight Python %}timeit{% endhighlight %} ставит свой временн<b>о</b>й эксперимент. Это делается для того, чтобы запускать тесты в среде с отсутствием бродячих переменных, которые вы могли создать и которые могут повлиять на производительность функции непредвиденным образом.</p>

<p>Из эксперимента выше очевидно, что операция {% highlight Python %}append{% endhighlight %} с 0.30 миллисекундами быстрее конкатенации с 6.54 миллисекундами. Также мы видим время, требуемое для двух дополнительных методов создания списков: использование конструктора списка с вызовом {% highlight Python %}range{% endhighlight %} и генератора списков. Интересно, что последний в два раза быстрее, чем цикл {% highlight Python %}for{% endhighlight %} с операцией {% highlight Python %}append{% endhighlight %}.</p>

<p>Наше последнее наблюдение в этом маленьком эксперименте заключается в том, что все времена, которые вы видите выше, содержат некоторую погрешность, возникающую при фактическом вызове тестовой функции. Однако, мы можем предположить, что для всех четырёх случаев эта величина одинакова, так что мы по-прежнему имеем адекватное сравнение операций. Поэтому правильнее говорить не "конкатенация занимает 6.54 миллисекунды", а "тестовая функция конкатенации выполняется 6.54 миллисекунд". В качестве упражнения вы можете провести временн<b>о</b>й тест для пустой функции и вычесть его результат из полученных выше чисел.</p>

<p>После того, как мы увидели, как непосредственно может быть измерена производительность, вы можете посмотреть в <i>таблицу 2</i>, чтобы узнать эффективность в терминах большого "О" для основных операций над списками. После вдумчивого размышления над ней, вы можете заинтересоваться двумя разными временами у {% highlight Python %}pop{% endhighlight %}. Когда этот метод вызывается для конца списка, то он имеет <b><i>O</i>(1)</b>. Но когда {% highlight Python %}pop{% endhighlight %} вызывают для первого или любого другого элемента из середины списка, его производительность <b><i>O(n)</i></b>. Причина кроется в том, как в Python выбрана реализация списков. Когда элемент берётся из начала списка, то все прочие элементы смещаются на одну позицию вперёд. Сейчас это может показаться вам глупым, но если вы посмотрите в <i>таблицу 2</i>, то увидите, что эта же реализация позволяет операции индексации иметь <b><i>O</i>(1)</b>. Это один из тех компромиссов, которые разработчики Python сочли разумными.</p>

<table border="1" align="center">
  <caption><b>Таблица 2: Эффективность операторов для списков в Python в терминах нотации "большое О"</b></caption>
  <tr>
    <td>Операция</td><td>Эффективность</td>
  </tr>
  <tr>
    <td>Индекс []</td><td>O(1)</td>
  </tr>
  <tr>
    <td>Присваивание по индексу</td><td>O(1)</td>
  </tr>
  <tr>
    <td>append</td><td>O(1)</td>
  </tr>
  <tr>
    <td>pop()</td><td>O(1)</td>
  </tr>
  <tr>
    <td>pop(i)</td><td>O(n)</td>
  </tr>
  <tr>
    <td>insert(i, item)</td><td>O(n)</td>
   </tr>
   <tr>
    <td>Оператор del</td><td>O(n)</td>
  </tr>
  <tr>
    <td>Итерирование</td><td>O(n)</td>
  </tr>
  <tr>
    <td>Вхождение (in)</td><td>O(n)</td>
  </tr>
  <tr>
    <td>Срез [x:y]</td><td>O(k)</td>
  </tr>
  <tr>
    <td>Удалить срез</td><td>O(n)</td>
  </tr>  
  <tr>
    <td>Задать срез</td><td>O(n + k)</td>
  </tr>  
  <tr>
    <td>Обратить</td><td>O(n)</td>
  </tr>
  <tr>
    <td>Конкатенация</td><td>O(k)</td>
  </tr>
  <tr>
    <td>Сортировка</td><td>O(n log n)</td>
  </tr>
  <tr>
    <td>Размножить</td><td>O(nk)</td>
  </tr>
</table>

<p>В качестве способа демонстрации этих различий в производительности, давайте проведём другой эксперимент с использованием модуля {% highlight Python %}timeit{% endhighlight %}. Нашей целью будет проверка производительности операции {% highlight Python %}pop{% endhighlight %} на списке известного размера, когда программа выталкивает элемент из конца списка, и ещё раз - когда извлекается элемент из начала списка. Мы также произведём замеры времени на списках разной длины. Что мы ожидаем увидеть, так это то, что временн<b>а</b>я зависимость у {% highlight Python %}pop{% endhighlight %} для конца списка остаётся одинаковой при увеличении его длины, в то время как для выталкивания из начала списка она будет расти вместе с увеличением размера.</p>

<p><i>Листинг 4</i> демонстрирует одну попытку замерить разницу между двумя использованиями {% highlight Python %}pop{% endhighlight %}. Как видно из первого примера, выталкивание с конца занимает 0.0003 миллисекунды, в то время как на выталкивание из начала требуется 4.82 миллисекунды. Для списка в два миллиона элементов коэффициент будет 16 000.</p>

<p>Есть ещё несколько замечаний относительно <i>листинга 4</i>. Первое - это оператор {% highlight Python %}from __main__ import x{% endhighlight %}. Несмотря на то, что мы не определяли функцию, мы хотим иметь возможность использовать список-объект {% highlight Python %}x{% endhighlight %} в нашем тесте. Этот подход позволяет замерять время только для единственной {% highlight Python %}pop{% endhighlight %}-операции и получать для неё наиболее точное значение времени. Поскольку замеры повторяются тысячу раз, то также важно отметить, что список уменьшается в размерах на единицу за каждую итерацию. Но из-за того, что изначально в нём два миллиона элементов, общий объём в итоге уменьшится примерно на 0.05%</p>

<b>Листинг 4</b>
{% highlight Python %}
popzero = timeit.Timer("x.pop(0)",
                       "from __main__ import x")
popend = timeit.Timer("x.pop()",
                      "from __main__ import x")

x = list(range(2000000))
popzero.timeit(number=1000)
4.8213560581207275

x = list(range(2000000))
popend.timeit(number=1000)
0.0003161430358886719
{% endhighlight %}

<p>Пока наш первый тест показывает, что {% highlight Python %}pop(0){% endhighlight %} действительно медленнее {% highlight Python %}pop(){% endhighlight %}. Но он не подтверждает утверждение, что {% highlight Python %}pop(0){% endhighlight %} имеет <b><i>O(n)</i></b>, в то время как {% highlight Python %}pop(){% endhighlight %} - <b><i>O(1)</i></b>. Чтобы доказать это, нам нужно рассмотреть производительность обоих вызовов на диапазоне размеров списков. <i>Листинг 5</i> осуществляет этот тест.</p>

<b>Листинг 5</b>
{% highlight Python %}
popzero = Timer("x.pop(0)",
                "from __main__ import x")
popend = Timer("x.pop()",
               "from __main__ import x")
print("pop(0)   pop()")
for i in range(1000000,100000001,1000000):
    x = list(range(i))
    pt = popend.timeit(number=1000)
    x = list(range(i))
    pz = popzero.timeit(number=1000)
    print("%15.5f, %15.5f" %(pz,pt))
{% endhighlight %}

<p>На <i>рисунке 3</i> показаны результаты нашего эксперимента. Вы можете видеть, как список делается всё длиннее и длиннее, и время, необходимое для {% highlight Python %}pop(0){% endhighlight %}, тоже увеличивается, тогда как график для {% highlight Python %}pop(){% endhighlight %} остаётся плоским. Это в точности то, что мы ожидали увидеть от алгоритмов с <b><i>O(n)</i></b> и <b><i>O(1)</i></b></p>

<p>Некоторым источником ошибок в этом маленьком эксперименте стал тот факт, что на компьютере запущены и другие процессы, которые могут замедлять наш код. Несмотря на то, что мы старались минимизировать влияние прочих происходящих на компьютере вещей, с ними связаны некоторые флуктуации времён. Именно поэтому цикл выполняет тест тысячу раз - в первую очередь, чтобы статистически собрать достаточно информации для утверждения о надёжности измерений.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/poptime.png"></p>
<p align="center">Рисунок 3: Сравнение производительности {% highlight Python %}pop(0){% endhighlight %} и {% highlight Python %}pop(){% endhighlight %}</p>

<h3>Словари</h3>
<p>Второй основной структурой данных в Python является словарь. Как вы, наверное, помните, словари отличаются от списков тем, что в них доступ к элементу предоставляется по ключу, а не по номеру позиции. Позднее в этой книге вы увидите множество способов реализации словаря. Сейчас же наиболее важно отметить, что операции получения и записи элемента в словарь имеют <b><i>O</i>(1)</b>. Другой важной операцией над словарём является определение принадлежности ему элемента. Проверка, есть ли в словаре данный ключ или нет, тоже <b><i>O</i>(1)</b>. Эффективности всех операций над словарями собраны в <i>таблице 3</i>. Одно лишь важное замечание: производительности, которые мы в ней предоставляем, являются усреднёнными. В редких случаях принадлежность, получение или запись элемента могут деградировать до <b><i>O(n)</i></b>. Мы столкнёмся с этим в одной из последующих глав, когда будем говорить о различных способах, которыми можно реализовать словарь.</p>

<table border="1" align="center">
  <caption><b>Таблица 3: Эффективность операций над словарями в Python в терминах нотации "большое О"</b></caption>
  <tr>
    <td>Операция</td><td>Эффективность</td>
  </tr>
  <tr>
    <td>Копирование</td><td>O(n)</td>
  </tr>
  <tr>
    <td>Получить элемент</td><td>O(1)</td>
  </tr>
  <tr>
    <td>Записать элемент</td><td>O(1)</td>
  </tr>
  <tr>
    <td>Удалить элемент</td><td>O(1)</td>
  </tr>
  <tr>
    <td>Принадлежность (in)</td><td>O(1)</td>
  </tr>
  <tr>
    <td>Итерации</td><td>O(n)</td>
  </tr>
</table>

<p>В нашем последнем эксперименте с производительностью мы сравним эффективность операций принадлежности у списков и словарей. В процессе мы подтвердим, что оператор принадлежности для списков имеет <b><i>O(n)</i></b>, а для словарей - <b><i>O</i>(1)</b>. Проводить сравнение мы будем просто: создадим список с диапазоном чисел, затем будем брать число случайным образом и смотреть, есть ли оно в списке. Если наша таблица производительности верна, то чем больше список, тем дольше будет происходить определение, содержится ли в нём данное число.</p>

<p>Потом повторим тот же эксперимент со словарём, содержащим числа в качестве ключей. В этом эксперименте мы хотим увидеть, что определение, присутствует или нет число в словаре, не только намного быстрее, но и время, занимаемое проверкой, остаётся постоянным, даже если объём словаря возрастает.</p>

<p><i>Листинг 6</i> реализовывает это сравнение. Заметьте, что мы выполняем в точности одинаковые операции {% highlight Python %}number in container{% endhighlight %}. Различие только в том, что в седьмой строке {% highlight Python %}x{% endhighlight %} - это список, а в девятой - словарь.</p>

<b>Листинг 6</b>
{% highlight Python %}
import timeit
import random

for i in range(10000,1000001,20000):
    t = timeit.Timer("random.randrange(%d) in x"%i,
                     "from __main__ import random,x")
    x = list(range(i))
    lst_time = t.timeit(number=1000)
    x = {j:None for j in range(i)}
    d_time = t.timeit(number=1000)
    print("%d,%10.3f,%10.3f" % (i, lst_time, d_time))
{% endhighlight %}

<p><i>Рисунок 4</i> подытоживает результаты запуска <i>Листинга 6</i>. Вы видите, что словарь работает стабильно быстрее. Для списков малых размеров на 10 000 элементов он быстрее в 89,4 раза. Для больших списков на 990 000 элементов разница становится в 11 603 раза! Вы также можете видеть, что время, требуемое операции проверки принадлежности для списка, линейно возрастает с ростом его размера. Это подтверждает наше утверждение, что оператор принадлежности для списков имеет <b><i>O(n)</i></b>. Так же хорошо видно, что аналогичная операция для словаря остаётся постоянной даже при возрастании его объёма. Фактически, для словаря размером в 10 000 опреация проверки принадлежности занимает 0,004 миллисекунды, как и для словаря на 990 000 элементов.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/listvdict.png"></p>
<p align="center">Рисунок 4: Сравнение операторов {% highlight Python %}in{% endhighlight %} для списков и словарей в Python</p>

<p>Поскольку Python - развивающийся язык, то у него "за сценой" постоянно происходят изменения. Последнюю информацюю о производительности структур данных в Python можно найти на сайте Python. На момент написания этих строк Python wiki имеет хорошую страничку, посвящённую временн<b>о</b>й сложности. Вы можете ознакомиться с ней <a href="http://wiki.python.org/moin/TimeComplexity">здесь</a>.</p>

<b>Самопроверка</b>
<p>Q-1: Какая из перечисленных операций для списков не является O(1)?</p>
<p>Q-2: Какая из перечисленных операций для словарей не является O(1)?</p>

<h2>Заключение</h2>
<ul>
  <li>Анализ алгоритмов - это независимый от реализации способ оценки алгоритма.</li>
  <li>Нотация большое "О" позволяет классифицировать алгоритмы по их доминирующим вычислениям относительно размера задачи.</li>
</ul>

<h2>Ключевые термины</h2>
<table align="center">
  <tr>
    <td>Временн<b>а</b>я сложность </td><td>Квадратичный </td><td>Линейный</td>
  </tr>
  <tr>
    <td>Линейно-логарифмический </td><td>Логарифмический </td><td>Наихудший случай</td>
  </tr>
  <tr>
    <td>Нотация большое "О" </td><td>
Полный перебор </td><td>Порядок величины </td>
  </tr>
  <tr>
    <td>Усреднённый случай </td><td>Установка меток </td><td>
Экспоненциальный </td>
  </tr>
</table>

<h2>Вопросы для обсуждения</h2>
<ol>
  <li>Какова производительность следующего фрагмента кода в терминах нотации большого "О"?
  {% highlight Python %}
  for i in range(n):
   for j in range(n):
      k = 2 + 2
  {% endhighlight %}</li>
  <li>Какова производительность следующего фрагмента кода в терминах нотации большого "О"?
  {% highlight Python %}
   for i in range(n):
     k = 2 + 2
  {% endhighlight %}</li>
  <li>Какова производительность следующего фрагмента кода в терминах нотации большого "О"?
  {% highlight Python %}
    i = n
    while i > 0:
      k = 2 + 2
      i = i // 2
  {% endhighlight %}</li>
  <li>Какова производительность следующего фрагмента кода в терминах нотации большого "О"?
  {% highlight Python %}
    for i in range(n):
      for j in range(n):
        for k in range(n):
          k = 2 + 2
  {% endhighlight %}</li>
  <li>Какова производительность следующего фрагмента кода в терминах нотации большого "О"?
  {% highlight Python %}
   for i in range(n):
     k = 2 + 2
   for j in range(n):
     k = 2 + 2
   for k in range(n):
     k = 2 + 2
  {% endhighlight %}</li>
</ol>

<h2>Упражнения</h2>
<ol>
  <li>Проведите эксперимент, подтверждающий, что оператор индекса для списков имеет <b><i>O</i>(1)</b></li>
  <li>Проведите эксперимент, подтверждающий, что получение и запись элемента в словарь имеют <b><i>O</i>(1)</b></li>
  <li>Проведите эксперимент, сравнивающий производительность оператора {% highlight Python %}del{% endhighlight %} для словарей и списков</li>
  <li>Для заданного списка чисел, расположенных в случайном порядке, напишите работающий за линейное время алгоритм поиска k-го наименьшего элемента. Объясните, почему ваш алгоритм - линейный.</li>
  <li>Можете вы улучшить алгоритм из предыдущего задания, чтобы он был <b><i> O(n</i> log(<i>n</i>))</b>?</li>
</ol>
