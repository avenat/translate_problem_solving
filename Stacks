<h1>Стеки</h1>

<h2>Что такое "стек"?</h2>
<p><b>Стек</b> (иногда говорят "магазин" - по аналогии с магазином огнестрельного оружия) - это упорядоченная коллекция элементов, где добавление нового или удаление существующих всегда происходит только на одном из концов. Этот конец обычно называют "вершиной", а противоположный ему - "основанием". </p>

<p>Важность основания стека в том, что хранящиеся ближе к нему элементы представляют из себя те, что находятся в стеке дольше всего. Элемент, добавленный последним, расположен на той позиции, с которой будет удалён в первую очередь. Такой принцип организации иногда называется <b>LIFO, last-in first-out</b> (<i>англ. «последним пришёл — первым вышел»</i>). Он предоставляет упорядочение по длительности нахождения в коллекции. Более новые элементы расположены ближе к вершине, в то время как более старые - ближе к основанию.</p>

<p>С примерами стека мы сталкиваемся ежедневно. Едва ли не каждая закусочная имеет стопку из подносов или тарелок, где вам нужно брать одну сверху, открывая новый поднос или тарелку для следующего посетителя в очереди. Вообразите стек из книг на столе (<i>рисунок 1</i>). Единственной книгой, чья обложка видна, является самая верхняя. Чтобы получить доступ к остальным в стопке, нам нужно удалить лежащую поверх остальных. <i>Рисунок 2</i> демонстрирует другой стек, содержащий несколько простых объектов данных Python.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/bookstack2.png"></p>
<p align="center">Рисунок 1: Стек из книг</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/primitive.png"></p>
<p align="center">Рисунок 2: Стек из простых объектов Python</p>

<p>Одна из наиболее часто используемых идей, связанных со стеком, пришла из простого наблюдения за тем, как добавляются и удаляются его элементы. Предположим, что вы начинаете с чистого стола. Теперь кладите книги по одной за раз друг поверх друга. Вы конструируете стек. Посмотрим, что случится, когда вы начнёте их удалять. Очерёдность, в которой это будет происходить, в точности противоположна тому, как они клались. Стеки фундаментально важны, поскольку их можно использовать для реверсирования порядка элементов. Последовательность вставок противоположена последовательности удалений. <i>Рисунок 3</i> показывает стек из объектов данных Python в процессе его создания и удаления из него элементов. Обратите внимание на порядок объектов.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/simplereversal.png"></p>
<p align="center">Рисунок 3: Свойство реверсирования у стеков</p>

<p>Рассматривая это реверсивное свойство, вы, возможно, подумаете о примерах стека, имеющих место в процессе использования вами компьютера. Например, каждый веб-браузер имеет кнопку "Назад". Когда вы перемещаетесь от одной веб-страницы к другой, они помещаются в стек (точнее, в стек помещаются их URL'ы). Текущая страница, которую вы просматриваете, находится на вершине, а самая первая из простмотренных - в основании. Если вы нажмёте кнопку "Назад", то начнёте перемещаться по страницам в обратном порядке.</p>

<h2>Абстрактный тип данных "стек"</h2>
<p>Абстрактный тип данных для стека определяется следующими структурой и операциями. Как писалось выше, стек организован как упорядоченная коллекция элементов, добавляемых и удаляемых из конца, называемого "вершина" (LIFO-упорядоченность). Ниже представлены операции над стеком.</p>

<ul>
<li>{% highlight Python %}Stack(){% endhighlight %} создаёт новый пустой стек. Параметры не нужны, возвращает пустой стек.</li>
<li>{% highlight Python %}push(item){% endhighlight %} добавляет новый элемент на вершину стека. В качестве параметра выступает элемент; функция ничего не возвращает.</li>
<li>{% highlight Python %}pop(){% endhighlight %} удаляет верхний элемент из стека. Параметры не требуются, функция возвращает элемент. Стек изменяется.</li>
<li>{% highlight Python %}peek(){% endhighlight %} возвращает верхний элемент стека, но не удаляет его. Параметры не требуются, стек не модифицируется.</li>
<li>{% highlight Python %}isEmpty(){% endhighlight %} проверяет стек на пустоту. Параметры не требуются, возвращает булево значение.</li>
<li>{% highlight Python %}size(){% endhighlight %} возвращает количество элементов в стеке. Параметры не требуются, тип результата - целое число.</li>
</ul>

<p>Например, если {% highlight Python %}s{% endhighlight %} - свежесозданный путой стек, то в <i>таблице 1</i> показаны результаты проведения над ним последовательности операций. Согласуясь с сущностью стека, верхний элемент будет самым правым в списке.</p>

<table border="1">
  <caption><b>Таблица 1: Простые стековые операции</b></caption>
  <tr>
    <td>Операция над стеком</td><td>Содержание стека</td><td>Возвращаемое значение</td></tr>
  <tr>
    <td>{% highlight Python %}s.isEmpty(){% endhighlight %}</td><td>{% highlight Python %}[]{% endhighlight %}</td><td>{% highlight Python %}True{% endhighlight %}</td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.push(4){% endhighlight %}</td><td>{% highlight Python %}[4]{% endhighlight %}</td><td></td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.push('dog'){% endhighlight %}</td><td>{% highlight Python %}[4,'dog']{% endhighlight %}</td><td></td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.peek(){% endhighlight %}</td><td>{% highlight Python %}[4,'dog']{% endhighlight %}</td><td>{% highlight Python %}'dog'{% endhighlight %}</td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.push(True){% endhighlight %}</td><td>{% highlight Python %}[4,'dog',True]{% endhighlight %}</td><td></td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.size(){% endhighlight %}</td><td>{% highlight Python %}[4,'dog',True]{% endhighlight %}</td><td>{% highlight Python %}3{% endhighlight %}</td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.isEmpty(){% endhighlight %}</td><td>{% highlight Python %}[4,'dog',True]{% endhighlight %}</td><td>{% highlight Python %}False{% endhighlight %}</td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.push(8.4){% endhighlight %}</td><td>{% highlight Python %}[4,'dog',True,8.4]{% endhighlight %}</td><td></td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.pop(){% endhighlight %}</td><td>{% highlight Python %}[4,'dog',True]{% endhighlight %}</td><td>{% highlight Python %}8.4{% endhighlight %}</td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.pop(){% endhighlight %}</td><td>{% highlight Python %}[4,'dog']{% endhighlight %}</td><td>{% highlight Python %}True{% endhighlight %}</td>
  </tr>
  <tr>
    <td>{% highlight Python %}s.size(){% endhighlight %}</td><td>{% highlight Python %}[4,'dog']{% endhighlight %}</td><td>{% highlight Python %}2{% endhighlight %}</td>
  </tr>
</table>

<h2>Реализация стека на Python</h2>
<p>Теперь, когда у нас есть чёткое определение стека, как абстрактного типа данных, обратим своё внимание на использование Python для реализации стека. Напомним, что когда мы даём физическую реализацию абстракного типа данных, то ссылаемся на реализацию структуры данных.</p>

<p>Как мы уже говорили в главе 1, в Python (как и в любом объектно-ориентированном языке) реализация выбранного абстрактного типа данных (например, стека) - это создание нового класса. Стековые операции воплотятся в его методах. Далее, чтобы реализовать стек, который суть - коллекция элементов, имеет смысл воспользоваться мощью и простотой примитивных коллекций, предоставляемых Python. Мы будем использовать список.</p>

<p>Напомним, что класс списка в Python предоставляет механизм и набор методов для упорядоченной коллекции. Например, если у нас есть список [2, 5, 3, 6, 7, 4], то нам нужно только определиться, который из его концов принять за вершину стека, а который - за базу. Как только решение принято, можно начинать реализовывать операции, используя такие списковые методы, как {% highlight Python %}append{% endhighlight %} и {% highlight Python %}pop{% endhighlight %}.</p>

<p>Нижеследующая реализация стека (<i>ActiveCode 1</i>) предполагает, что верхний элемент стека расположен в конце списка. По мере роста стека (имеет место операция {% highlight Python %}push{% endhighlight %}), новые элементы будут добавляться туда же. Им же будет манипулировать операция {% highlight Python %}pop{% endhighlight %}.</p>

<p align="center"><b>Active Code: 1</b> Реализация класса Stack с использованием списков Python</p>

<p>Помните, что с нажатием кнопки {% highlight Python %}run{% endhighlight %} не произойдёт ничего, кроме объявления класса. Мы должны создать объект {% highlight Python %}Stack{% endhighlight %}, а затем его использовать. <i>ActiveCode 2</i> демонстрирует класс {% highlight Python %}Stack{% endhighlight %} в действии, которое мы представили последовательностью операций из <i>таблицы 1</i>.</p>

<p align="center"><b>Active Code: 2</b> </p>

<p>Важно отметить, что мы можем выбрать реализацию стека через список, где вершиной считается первый, а не последний элемент. В этом случае предыдущие методы {% highlight Python %}append{% endhighlight %} и {% highlight Python %}pop{% endhighlight %} работать не будут. Мы должны будем явно использовать {% highlight Python %}pop{% endhighlight %} и {% highlight Python %}insert{% endhighlight %} для позиции с индексом 0 (первый элемент в списке). Реализация показана в <i>CodeLens 1</i></p>

<p align="center"><b>Code Lens: 1 Альтернативная реализация класса Stack</b> </p>

<p>Эта возможность изменять физическое воплощение абстрактного типа данных при поддержке логических характеристик - пример того, как работает абстракция. Однако, даже если стек будет вести себя аналогично, рассмотрение производительности этих двух реализаций покажет их несомненное различие. Напомним, что операции {% highlight Python %}append{% endhighlight %} и {% highlight Python %}pop{% endhighlight %} обе являются О(1). Это означает, что первая реализация будет выполнять добавление и выталкивание за постоянное время, независимо от количества элементов в стеке. Производительность второго варианта страдает, поскольку и {% highlight Python %}insert(0){% endhighlight %}, и {% highlight Python %}pop(0){% endhighlight %} для стека, размером n, являются O(n). Очевидно, что даже если реализации логически эквивалентны, то  при тестировании они будут иметь очень разные затраты по времени.</p>

<b>Самопроверка</b>
<p>stk-1. Дана следующая последовательность стековых операций. Что будет на вершине стека, когда последовательность завершится?</p>

<p>stk-2. Дана следующая последовательность стековых операций. Что будет на вершине стека, когда последовательность завершится?</p>

<p>Напишите функцию {% highlight Python %}revstring(mystr){% endhighlight %}, используя стек для изменеия порядка символов в строке на противоположный.</p>

<h2>Простые сбаласированные скобки</h2>
<p>А теперь обратим наше внимание на использование стека при решении реальных задач в информатике. У вас не возникает сомнений при написании, например, такого арифметического выражения:</p>

<p>(5+6)&lowast;(7+8)/(4+3)</p>

<p>где скобки используются для задания порядка вычисления операций. Вы также можете иметь некоторый опыт программирования на языке вроде Лиспа с конструкциями наподобие</p>

{% highlight Lisp %}
(defun square(n)
     (* n n))
{% endhighlight %}

<p>Здесь определена функция {% highlight Python %}square{% endhighlight %}, возвращающая квадрат аргумента {% highlight Python %}n{% endhighlight %}. Лисп славится использованием огромного множества скобок.</p>

<p>В обоих примерах скобки должны появляться сбалансированным образом. <b>Сбалансированность скобок</b> означает, что каждый открывающий символ имеет соответствующий ему закрывающий, и пары скобок правильно вложены друг в друга. Рассмотрим следующие строки корректно сбалансированных скобок:</p>

<pre>
(()()()())

(((())))

(()((())()))
</pre>

<p>Сравним их со следующими, несбалансированными:</p>

<pre>
((((((())

()))

(()()(()
</pre>

<p>Способность различать, какие скобки сбалансированы корректно, а какие нет - важная часть распознавания структур во многих языках программирования.</p>

<p>Таким образом, задача заключается в написании алгоритма, читающего строку из скобок слева неправо и определяющего, являются ли они сбалансированными. Чтобы найти решение, нам нужно сделать важное наблюдение. Обрабатывая символы слева направо, чаще всего вы встретитесь с тем, что последняя открывающая скобка соответствует следующей закрывающей (см. <i>рисунок 4</i>). Так же обработка самого первого открывающего символа может откладываться, пока с ним не будет связан самый последний в строке. Закрывающие символы соотносятся с открывающими в порядке, обратном их появлению - изнутри наружу. Это явный признак того, что для решения данной задачи можно использовать стек.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/simpleparcheck.png"></p>
<p align="center">Рисунок 4: Связывание скобок</p>

<p>Как только вы соглашаетесь, что стек является подходящей структурой данных для хранения скобок, положения алгоритма становятся очевидными. Начиная с пустого стека, строка скобок обрабатывается слева направо. Если символ - открывающая скобка, то она кладётся в стек, как напоминание, что соответствующий закрывающий знак должен появиться позже. С другой стороны, если символ - закрывающая скобка, то из стека выталкивается верхний элемент. До тех пор, пока будет происходить выталкивание для соотнесения каждого закрывающего символа, скобки будут сбалансированными. Если в какой-то момент в стеке не окажется открывающей скобки для связи с закрывающим символом, то строка является несбалансированной. В конце строки, когда будут обработаны все символы, стек должен быть пуст. Реализующий этот алгоритм код на Python показан в <i>ActiveCode 4</i></p>

<p align="center"><b>Active Code: 4</b> Решение задачи балансирования скобок</p>

<p>Данная функция, {% highlight Python %}parChecker{% endhighlight %}, предполагает доступность класса {% highlight Python %}Stack{% endhighlight %} и возвращает булев результат, сообщающий, сбалансирована ли строка. Обратите внимание, что булева переменная {% highlight Python %}balanced{% endhighlight %} инициализируется {% highlight Python %}True{% endhighlight %}, поскольку в начале у нас нет причин предполагать обратное. Если текущим символом является {% highlight Python %}({% endhighlight %}, то она помещается в стек (строки 9-10). Обратите внимание, что в строке 15 {% highlight Python %}pop{% endhighlight %} просто удаляет символ из стека. Возвращаемое значение не используется, поскольку мы знаем, что это должна быть открывающая скобка, встреченная ранее. В конце (строки 19-22), при условии, что выражение сбалансировано и стек абсолютно пуст, делается вывод, что входной параметр представляет из себя правильно сбалансированную последовательность скобок.</p>

<h2>Сбалансированные символы (общий случай)</h2>
<p>Показанная выше задача о сбалансированных скобках является частным случаем более общей ситуации, возникающей во многих языках программирования. Обобщённая проблема балансировки и вложенности различных типов открывающих и закрывающих символов возникает очень часто. Например, в Python квадратные скобки, {% highlight Python %}[{% endhighlight %} и {% highlight Python %}]{% endhighlight %}, используются для списков, фигурные скобки, {% highlight Python %}{{% endhighlight %} и {% highlight Python %}}{% endhighlight %}, - для словарей, а круглые ({% highlight Python %}({% endhighlight %} и {% highlight Python %}){% endhighlight %}) - для кортежей и арифметических выражений. Можно сколько угодно перемешивать символы до тех пор, пока каждый из них поддерживает свои открывающие и закрывающие отношения. Для строк вроде</p>

<pre>
{ { ( [ ] [ ] ) } ( ) }

[ [ { { ( ( ) ) } } ] ]

[ ] [ ] [ ] ( ) { }
</pre>

<p>"хорошая сбалансированность" заключается не только в том, что каждый открывающий символ имеет соответствующий закрывающий, но и в совпадении типов этих символов.</p>

<p>Сравните верхний пример со следующими несбалансированными строками:</p>

<pre>
( [ ) ]

( ( ( ) ] ) )

[ { ( ) ]
</pre>

<p>Простой контролёр скобок из предущего раздела может быть легко расширен для обработки этих новых типов символов. Напомним, что каждый открывающий символ просто помещается в стек в ожидании появления в последовательности соответствующего закрывающего символа. Когда это происходит, единственная разница в том, что мы должны проверить, корректна ли связь с типом символа на вершине стека. Если они не соответствуют друг другу, то строка не сбалансирована. Аналогично, если вся входная последовательность обработана и стек пуст, то строка сбалансирована правильно.</p>

<p>Реализующая это программа на Python показана в <i>ActiveCode 5</i>. Единственное изменение коснулось строки 16, где вызввается вспомогательная функция {% highlight Python %}matches{% endhighlight %}, помогающая с соотнесением символов. Каждый символ, удаляемый из стека, должен быть проверен, чтобы убедиться, что он верно сопоставляется с текущим закрывающим символом. Если возникает ошибка, то булева переменная {% highlight Python %}balanced{% endhighlight %} устанавливается в {% highlight Python %}False{% endhighlight %}</p>

<p align="center"><b>Active Code: 5</b> Решение общего случая балансирования символов</p>

<p>Эти два примера показывают, что стеки - очень важная структура данных для обработки языковых конструкций в информатике. Практически любая нотация, о которой вы можете подумать, имеет некоторый тип вложенных символов, которые должны согласовываться между собой сбалансированным образом. Кроме вышеизложенного, есть целый ряд других важных применений стеков в области информатики. Мы продолжим их исследовать в следующем разделе.</p>

<h2>Конвертирование десятичных чисел в двоичные</h2>
<p>Изучая информатику, вы, вероятно, так или иначе сталкивались с идеей бинарных чисел. Двоичное представление важно в информатике, поскольку все значения, хранящиеся в компьютере, представляют собой строки двоичных цифр, строки из нулей и единиц. Без возможности конвертации в одну и другую сторону между общепринятым представлением и двоичным нам бы пришлось взаимодействовать с компьютерами весьма неудобными способами.</p>

<p>Целые числа - очень распространённые элементы данных. Они постоянно используются в компьютерных программах и вычислениях. Мы изучаем их на уроках математики и, конечно, представляем в десятичной системе счисления (по основанию 10). Десятичное число 233<sub>10</sub> и связанный с ним эквивалент 11101001<sub>2</sub> соответственно интерпретируются как</p>

<pre>2×10<sup>2</sup>+3×10<sup>1</sup>+3×10<sup>0</sup></pre>

<p>и</p>

<pre>1×2<sup>7</sup>+1×2<sup>6</sup>+1×2<sup>5</sup>+0×2<sup>4</sup>+1×2<sup>3</sup>+0×2<sup>2</sup>+0×2<sup>1</sup>+1×2<sup>0</sup></pre>

<p>Но как нам легко конвертировать целые значения в бинарные числа? Ответ заключается в алгоритме под названием "Разделяй на 2", который использует стек для запоминания цифр двоичного результата.</p>

<p>Алгоритм "Разделяй на 2" подразумевает, что мы начинаем с целого большего, чем нуль. Затем простыми итерациями последовательно делим десятичное число на два и записываем остаток. Первое деление пополам даёт информацию о том, является ли число чётным или нечётным. Чётное число будет иметь в остатке нуль и цифру 0 на первом месте. Нечётное значение будет иметь в остатке единицу и цифру 1 на первом месте. Мы думаем о постоении нашего двоичного числа как о последовательности цифр; первый вычисленный нами остаток фактически будет последней цифрой в последовательности. Как показано на <i>рисунке 5</i>, мы снова наблюдаем свойство разворота входных данных, сигнализирующее, что, вполне вероятно, подходящей структурой для решения задачи будет стек.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/dectobin.png"></p>
<p align="center">Рисунок 5: Преобразование числа из десятичного в бинарное</p>

<p>Код на Python в <i>ActiveCode 6</i> реализует алгоритм "Разделяй на 2". Функция {% highlight Python %}divideBy2{% endhighlight %} принимает десятичное число в качестве аргумента и последовательно делит его пополам. В строке 7 используется встроенный оператор остатка от деления %, чтобы выделить остаток и в строке 8 поместить его в стек. После того, как процесс деления закончится нулём, в строках 11-13 собирается бинарная последовательность. Строка 11 создаёт пустую строку. Из стека по одной выталкиваются двоичные цифры и добавляются к ней справа. В итоге возвращается бинарный результат.</p>

<p align="center"><b>Active Code: 6</b> Преобразование числа из десятичного в бинарное</p>

<p>Алгоритм бинарного преобразования может быть легко расширен для конвертации по любому основанию. В информатике широко используется несколько различных кодировок. Наиболее рапространены двоичная, восьмеричная и шестнадцатиричная.</p>

<p>Десятичное число 233 и связанные с ним восьмеричный и шестнадцатиричный эквиваленты 351<sub>8</sub> и E9<sub>16</sub> интерпретируются как</p>

<pre>3×8<sup>2</sup>+5×8<sup>1</sup>+1×8<sup>0</sup></pre>

<p>и</p>

<pre>14×16<sup>1</sup>+9×16<sup>0</sup></pre>

<p>Функция {% highlight Python %}divideBy2{% endhighlight %} может быть модифицирована, чтобы принимать не только десятичные значения, но и основание для предназначенного преобразования. Идея "Разделяй на 2" просто заменяется на более общую "Разделяй на основание". Новая функция под названием {% highlight Python %}baseConverter{% endhighlight %}, показанная в <i>ActiveCode 7</i>, принимает в качестве параметров десятичное число и любое основание между 2 и 16. Остатки по-прежнему помещаются в стек до тех пор, пока конвертируемое значение не станет равным нулю. Аналогичная техника конструирования слева направо может использоваться с одним небольшим изменением. От основания 2 до 10 для чисел нужно максимум 10 цифр, так что обычные символы 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9 работают нормально. Проблемы возникают, когда мы выходим за основание 10. Мы больше не можем использовать остатки, поскольку они сами представляются как двуциферные десятичные числа. Вместо них мы должны создать свой набор цифр, которые можно использовать для представления таких остатков за пределами 9.</p>

<p align="center"><b>Active Code: 7</b> Преобразование числа из десятичного в число по любому основанию</p>

<p>Решением этой задачи будет расширить набор цифр включением некоторых алфавитных символов. Например, шестнадцатиричная система счисления использует десять десятичных цифр вместе с первыми шестью буквами алфавита для своих шестнадцати цифр. Чтобы воплотить это, создаётся цифровая строка  (см. строку 4 в <i>листинге 6</i>), как хранилище цифр на соответствующих позициях. 0 - на позиции 0, 1 - на позиции 1, А - на позиции 10, В - на позиции 11 и так далее. Когда остаток удаляется из стека, он может быть использован в качестве индекса в цифровой строке, и к концу ответа добавляется правильная итоговая цифра. Например, если из стека удаляется остаток 13, в результирующую строку добавляется цифра D.</p>

<b>Самопроверка</b>
<p>Каково значение 25 в восьмеричной системе счисления?</p>
<p>Каково значение 256 в шестнадцатеричной системе счисления?</p>
<p>Каково значение 26 в системе счисления по основанию 26?</p>

<h2>Инфиксные, префиксные и постфиксные выражения</h2>
<p>Когда вы записывате арифметическое выражение вроде B * C, то его форма предоставляет вам достаточно информации для корректной интерпретации. В данном случае мы знаем, что переменная B умножается на переменную C, поскольку оператор умножения * находится в выражении между ними. Такой тип записи называется <b>инфиксной</b>, поскольку оператор расположен <i>между</i> (<i>in between</i>) двух операндов, с которыми он работает.</p>

<p>Рассмотрим другой инфиксный пример: A + B * C. Операторы + и * по-прежнему располагаются между операндами, но тут уже есть проблема. С какими операндами они будут работать? + работает с A и B или * принимает B и C? Выражение выглядит неоднозначно.</p>

<p>Фактически, вы можете читать и писать выражения такого типа долгое время, и они не будут вызывать у вас вопросов. Причина в том, что вы кое-что знаете о + и *. Каждый оператор имеет свой <b>приоритет</b>. Операторы с высоким приоритетом используются прежде операторов с низким. Единственной вещью, которая может изменить порядок приоритетов, являются скобки. Для арифметических операций умножение и деление стоят выше сложения и вычитания. Если появляются два оператора одинакового приоритета, то используются порядок слева направо или их ассоциативность.</p>

<p>Давайте интерпретируем вызвавшее затруднение выражение A + B * C, используя приоритет операторов. B и C перемножаются первыми, затем к результату добавляется A. (A + B) * C заставит выполнить сложение A и B перед умножением. В выражении A + B + C по очерёдности (через ассоциативность) первым будет вычисляться самый левый +.</p>

<p>Хотя это и может быть очевидным для вас, помните, что компьютер нуждается в точном знании того, как и в какой последовательности вычисляются операторы. Одним из способов записи выражения, гарантирующим, что не возникнет путаницы по отношению к порядку операций, является создание того, что называется выражением <b>с полностью расставленными скобками</b>. Такой тип выражения использует пару скобок для каждого оператора. Скобки диктуют порядок операций, так что здесь не возникает многозначности. Так же отпадает необходимость помнить правила расставления приоритетов.</p>

<p>Выражение A + B * C может быть переписано как ((A + (B * C)) + D) с целью показать, что умножение происходит в первую очередь, а затем следует крайнее левое сложение. A + B + C + D перепишется в (((A + B) + C) + D), поскольку операции сложения ассоциируются слева направо.</p>

<p>Существует ещё два очень важных формата выражений, которые на первый взгляд могут показаться вам неочевидными. Рассмотрим инфиксную запись A + B. Что произойдёт, если мы поместим оператор перед двумя операндами? Результирующее выражение будет  + A B. Также мы можем переместить оператор в конец, получив A B +. Всё это выглядит несколько странным.</p>

<p>Эти изменения позиции оператора по отношению к операндам создают два новых формата - <b>префиксный</b> и <b>постфиксный</b>. Префиксная запись выражения требует, чтобы все операторы предшествовали двум операндам, с которыми они работают. Постфиксная, в свою очередь, требует, чтобы операторы шли после соответствующих операндов. Несколько дополнительных примеров помогут прояснить этот момент (см. <i>таблицу 2</i>).</p>

<p>A + B * C можно переписать как + A * B C в префиксной нотации. Оператор умножения ставится непосредственно перед операндами B и C, указывая на приритет * над +. Затем следует оператор сложения перед A и результатом умножения.</p>

<p>В постфиксной записи выражение выглядит как A B C * +. Порядок операций вновь сохраняется, поскольку * находится непосредственно после B и C, обозначая, что он имеет приоритет выше следующего +. Хотя операторы перемещаются и теперь находятся до или после соответсвующих операндов, порядок последних по отношению друг к другу остаётся в точности таким, как был.</p>

<table border="1">
  <caption><b>Таблица 2: Примеры инфиксной, префиксной и постфиксной записи</b></caption>
  <tr>
    <td>Инфиксная запись</td><td>Префиксная запись</td><td>Постфиксная запись</td>
  </tr>
  <tr>
    <td>A + B</td><td>+ A B</td><td>A B +</td>
  </tr>
  <tr>
    <td>A + B * C</td><td>+ A * B C</td><td>A B C * +</td>
  </tr>
</table>

<p>А сейчас рассмотрим инфиксное выражение (A + B) * C. Напомним, что в этом случае запись требует наличия скобок для указания выполнить сложение перед умножением. Однако, когда A + B записывается в префиксной форме, то оператор сложения просто помещается перед операндами:  + A B. Результат этой операции является первым операндом для умножения. Оператор умножения перемещается в начало всего выражения, давая нам * + A B C. Аналогично, в постфиксной записи A B + явно указывается, что первым происходит сложение. Умножение может быть выполнено для получившегося результата и оставшегося операнда C. Соответствующим постфиксным выражением будет A B + C *.</p>

<p>Рассмотрим эти три выражения ещё раз (см. <i>таблицу 3</i>). Происходит что-то очень важное. Куда ушли скобки? Почему они не нужны нам в префиксной и постфиксной записи? Ответ в том, что операторы больше не являются неоднозначными по отношению к своим операндам. Только инфиксная запись требует дополнительных символов. Порядок операций внутри префиксного и постфиксного выражений полностью определён позицией операторов и ничем иным. Во многом именно это делает инфиксную запись наименее желательной нотацией для использования.</p>

<table border="1">
  <caption><b>Таблица 3: Выражение со скобками</b></caption>
  <tr>
    <td>Инфиксное выражение</td><td>Префиксное выражение</td><td>Постфиксное выражение</td>
  </tr>
  <tr>
    <td>(A + B) * C</td><td>* + A B C</td><td>A B + C *</td>
  </tr>
</table>

<p><i>Таблица 4</i> демонстрирует некоторые дополнительные примеры инфиксных выражений и эквивалентных им префиксных и постфиксных записей. Убедитесь, что вы понимаете, почему они эквивалентны с точки зрения порядка выполнения операций.</p>

<table border="1">
  <caption><b>Таблица 4: Дополнительные примеры инфиксной, префиксной и постфиксной записи</b></caption>
  <tr>
    <td>Инфиксное выражение</td><td>Префиксное выражение</td><td>Постфиксное выражение</td>
  </tr>
  <tr>
    <td>A + B * C + D</td><td>+ + A * B C D</td><td>A B C * + D +</td>
  </tr>
  <tr>
    <td>(A + B) * (C + D)</td><td>* + A B + C D</td><td>A B + C D + *</td>
  </tr>
  <tr>
    <td>A * B + C * D</td><td>+ * A B * C D</td><td>A B * C D * +</td>
  </tr>
  <tr>
    <td>A + B + C + D</td><td>+ + + A B C D</td><td>A B + C + D +</td>
  </tr>
</table>

<h3>Преобразование инфиксного выражения в префиксное и постфиксное</h3>

<p>До сих пор мы использовали специальные методы для преобразования между инфиксными выражениями и эквивалентными им префиксной и постфикской записями. Как вы можете ожидать, существуют алгоритмические способы выполнения таких преобразований, позволяющие корректно трансформировать любое выражение любой сложности.</p>

<p>Первой из рассматриваемых нами техник будет использование идеи полной расстановки скобок в выражении, рассмотренной нами ранее. Напомним, что A + B * C можно записать как (A + (B * C)), чтобы явно показать приоритет умножения перед сложением. Однако, при более близком рассмотрении вы увидите, что каждая пара скобок также отмечает начало и конец пары операндов с соответствующим оператором по середине.</p>

<p>Взгляните на правую скобку в подвыражении (B * C) выше. Если мы передвинем символ умножения с его позиции и удалим соответствующую левую скобку, получив B C *, то полученный эффект конвертирует подвыражение в постфиксную нотацию. Если оператор сложения тоже передвинуть к соответствующей правой скобке и удалить связанную с ним левую скобку, то результатом станет полное постфиксное выражение (см. <i>рисунок 6</i>).</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/moveright.png"></p>
<p align="center">Рисунок 6: Перемещение операторов вправо для постфиксной записи</p>

<p>Если мы сделаем тоже самое, но вместо передвижения символа на позицию к правой скобке, сдвинем его к левой, то получим префиксную нотацию (см. <i>рисунок 7</i>). Позиция пары скобок на самом деле является ключом к окончательной позиции заключённого между ними оператора.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/moveleft.png"></p>
<p align="center">Рисунок 7: Перемещение операторов влево для префиксной записи.</p>

<p>Таким образом, с целью преобразования выражения (неважно, насколько сложного) в префиксную или постфиксную запись, для установления порядка выполнения операций используется полная расстановка скобок. Затем передвигайте находящийся внутри них оператор на крайнюю левую или крайнюю правую позицию - в зависимости от того, префиксную или постфиксную запись вы хотите получить.</p>

<p>Вот более сложное выражение: (A + B) * C - (D - E) * (F + G). <i>Рисунок 8</i> демонстрирует его преобразование в постфиксный и префиксный виды.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/complexmove.png"></p>
<p align="center">Рисунок 8: Преобразование сложного выражения к префиксной и постфиксной записи.</p>

<h3>Обобщённое преобразование из инфиксного в постфиксный вид</h3>

<p>Нам необходимо разработать алгоритм преобразования любого инфиксного выражения в постфиксное. Для этого посмотрим ближе на сам процесс конвертирования.</p>

<p>Рассмотрим ещё раз выражение A + B * C. Как было показано выше, его постфиксным эквивалентом является A B C * +. Мы уже отмечали, что операнды A, B и C остаются на своих местах, а местоположение меняют только операторы. Ещё раз взглянем на операторы в инфиксном выражении. Первым при проходе слева направо нам попадётся +. Однако, в постфиксном выражении + находится в конце, так как следующий оператор, *, имеет приоритет над сложением. Порядок операторов в первоначальном выражении обратен результирующему постфисному выражению.</p>

<p>В процессе обработки выражения операторы должны где-то храниться, пока не найден их соответствующий правый операнд. Также порядок этих сохраняемых операторов может быть обратным (из-за их приоритета). Это случай со сложением и умножением в данном примере. Поскольку оператор сложения, появляющийся перед оператором умножения, имеет более низкий приоритет, то он должен появиться после использования оператора умножения. Из-за такого обратного порядка имеет смысл рассмотреть использование стека для хранения операторов до тех пор, пока они не понадобятся.</p>

<p>Что насчёт (A + B) * C? Напомним, что его постфиксный эквивалент A B + C *. Повторися, что обрабатывая это инфиксное выражение слева направо, первым мы встретим +. В этом случае, когда мы увидим *, + уже будет помещён в результирующее выражение, поскольку имеет преимущество над * в силу использования скобок. Теперь можно начать рассматривать, как будет работать алгоритм преобразования. Когда мы видим левую скобку, мы сохраняем её как знак, что должен будет появиться другой оператор с высоким приоритетом. Он будет ожидать, пока не появится соответствующая правая скобка, чтобы отметить его местоположение (вспомните технику полной расстановки скобок). После появления правой скобки оператор выталкивается из стека.</p>

<p>Поскольку мы сканируем инфиксное выражение слева направо, то будем использовать стек для хранения операторов. Это предоставит нам обратный порядок, который мы отмечали в первом примере. На вершине стека всегда будет последний сохранённый оператор. Когда бы мы не прочитали новый оператор, мы должны сравнить его по приоритету с операторами в стеке (если таковые имеются).</p>

<p>Предположим, что инфиксное выражение есть строка токенов, разделённых пробелами. Токенами операторов являются *, /, + и - вместе с правой и левой скобками, ( и ). Токены операндов - это однобуквенные идентификаторы A, B, C и так далее. Следующая последовательность шагов даст строку токенов в постфиксном порядке.</p>

<ol>
  <li>Создать пустой стек с названием {% highlight Python %}opstack{% endhighlight %} для хранения операторов. Создать пустой список для вывода.</li>
  <li>Преобразовать инфиксную строку в список, используя строковый метод {% highlight Python %}split{% endhighlight %}.</li>
  <li>Сканировать список токенов слева направо.
    <ul>
        <li>Если токен является операндом, то добавить его в конец выходного списка.</li>
        <li>Если токен является левой скобкой, положить его в {% highlight Python %}opstack{% endhighlight %}.</li>
        <li>Если токен является правой скобкой, то выталкивать элементы из {% highlight Python %}opstack{% endhighlight %} пока не будет найдена соответствующая левая скобка. Каждый оператор добавлять в конец выходного списка.</li>
        <li>Если токен является оператором *, /, + или -, поместить его в {% highlight Python %}opstack{% endhighlight %}. Однако, перед этим удалить любой из операторов, уже находящихся в {% highlight Python %}opstack{% endhighlight %}, который имеет больший или равный приоритет, и добавить его в выходной список.</li>
    </ul>
  </li>
  <li>Когда входное выражение будет полностью обработано, проверить {% highlight Python %}opstack{% endhighlight %}. Любые операторы, всё ещё находящиеся в нём, следует удалить и добавить в конец результирующего списка.</li>
</ol>

<p><i>Рисунок 9</i> демонстрирует алгоритм преобразования, работающий над выражением A * B + C * D. Заметьте, что первый оператор * удаляется до того, как мы встречаем оператор +. Также + остаётся в стеке, когда появляется второй *, поскольку умножение имеет приоритет перед сложением. В конце инфиксного выражения из стека дважды происходит выталкивание, удаляя оба оператора и помещая + как последний элемент в результирующее постфиксное выражение.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/intopost.png"></p>
<p align="center">Рисунок 9: Преобразование A * B + C * D в постфиксную запись</p>

<p>Для того, чтобы закодировать алгоритм на Python, мы будем использовать словарь под именем {% highlight Python %}prec{% endhighlight %} для хранения значений приоритета операторов. Он связывает каждый оператор с целым числом, которые можно сравнивать с другими операторами как уровень приоритетности (мы произвольно выбрали для этого целые числа 3, 2 и 1). Левая скобка получит самое низкое значение. Таким образом, любой сравниваемый с ней оператор будет иметь приоритет выше и располагаться над ней. Строка 15 определяет, что операнды могут быть любыми символами в верхнем регистре или цифрами. Полная функция преобразования показана в <i>ActiveCode 8</i>.</p>

<p align="center"><b>Active Code: 8</b> Преобразование инфиксного выражения в постфиксное</p>

<p>Ниже показаны ещё несколько примеров выполнения кода в оболочке Python.</p>

{% highlight Python %}
>>> infixtopostfix("( A + B ) * ( C + D )")
'A B + C D + *'
>>> infixtopostfix("( A + B ) * C")
'A B + C *'
>>> infixtopostfix("A + B * C")
'A B C * +'
>>>
{% endhighlight %}

<h3>Постфиксные вычисления</h3>
<p>В последнем примере использования стека мы рассмотрим вычисление выражения, которое уже находится в постфиксной форме. В этом случае стек вновь выбран структурой данных для решения задачи. Однако, поскольку вы сканируете постфиксное выражение, ждать своей очереди должны уже операнды, а не операторы, в противоположность алгортму выше. Ещё один способ думать об этом решении: когда на входе обнаружится оператор, для вычисления будут использованы два самых последних операнда.</p>

<p>Чтобы увидеть это более детально, рассмотрим постфиксное выражение {% highlight Python %}4 5 6 * +{% endhighlight %}. Сканируя его слева направо, прежде всего вы натолкнётесь на операнды 4 и 5. Что с ними делать вы не узнаете, пока не увидите следующий символ. Помещение каждого из них в стек гарантирует их доступность на случай, если следующим появится оператор.</p>

<p>В нашем случае следующий символ - ещё один операнд. Так что, как и раньше, помещаем его в стек и проверяем следующий символ. Теперь мы видим оператор *. Это означает, что два самых последних операнда нужно перемножить. Сделав дважды выталкивание из стека, мы получим необходимые множители, а затем выполним умножение (в данном случае результатом будет 30).</p>

<p>Теперь мы можем обработать полученное значение, поместив его обратно в стек, чтобы оно могло использоваться в качестве операнда для последующих операторов в выражении. Когда будет обработан последний оператор, в стеке останется только одно значение. Выталкиваем его и возвращаем как результат выражения. <i>Рисунок 10</i> демонстрирует содержание стека на протяжении всего процесса вычисления выражения из примера.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/evalpostfix1.png"></p>
<p align="center">Рисунок 10: Содержание стека в процессе вычисления</p>

<p>На <i>рисунке 11</i> показан несколько более сложный пример: 7 8 + 3 2 + /. Здесь есть два момента, которые стоит отметить. Первый: размер стека возрастает, сужается и вновь растёт в процессе вычисления подвыражений. Второй: обрабатывать оператор деления нужно очень внимательно. Напомним, что операнды в постфиксном выражении идут в их изначальном порядке, поскольку постфикс меняет только положение оператора. Когда операнды деления выталкиваются из стека, они находятся в обратной последовательности. Поскольку деление <i>не</i> коммутативный оператор (другими словами, 15/5 не то же самое, что 5/15), мы должны быть уверены, что порядок операндов не изменился.</p>

<p align="center"><img src="http://interactivepython.org/runestone/static/pythonds/_images/evalpostfix2.png"></p>
<p align="center">Рисунок 11: Более сложный пример вычисления</p>

<p>Предположим, что постфиксное выражение - это строка токенов, разделённых пробелами. Операторами являются *, /, + и -, а под операндами понимаются одноразрядные целые значения. На выходе будет целочисленный результат.</p>

<ol>
  <li>Создать пустой стек под названием {% highlight Python %}operandStack{% endhighlight %}.</li>
  <li>Преобразовать строку в список, используя строковый метод {% highlight Python %}split{% endhighlight %}</li>
  <li>Сканировать список токенов слева направо.
  <ul>
    <li>Если токен является операндом, преобразовать его из строки в целое число и поместить значение в {% highlight Python %}operandStack{% endhighlight %}.</li>
    <li>Если токен является оператором *, /, + или -, то он нуждается в двух операндах. Произвести выталкивание из {% highlight Python %}operandStack{% endhighlight %} дважды. Сначала вытолкнется второй операнд, а затем - первый. Выполнить арифметическую операцию. Поместить результат обратно в {% highlight Python %}operandStack{% endhighlight %}.</li>
  </ul>
  </li>
  <li>Когда входное выражение полностью обработано, его результат находится в стеке. Вытолкнуть его из {% highlight Python %}operandStack{% endhighlight %} и возвратить в качестве результата.</li>
</ol>

<p>Полностью функция для вычисления постфиксных выражений показана в <i>ActiveCode 9</i>. Для помощи с арифметикой определена вспомогательная функция {% highlight Python %}doMath{% endhighlight %}. Она принимает два операнда и оператор, после чего совершает надлежащую арифметическую операцию.</p>

<p align="center"><b>Active Code: 9</b> Постфиксное вычисление</p>

<p>Важно отметить, что для обеих программ - постфиксного преобразования и постфиксного вычисления, - мы предполагаем, что во входном выражении нет ошибок. Используя эти программы, как точку отсчёта, вы можете легко увидеть, как в них могут быть включены определение ошибок и сообщение об этом. Мы оставляем это как упражнение в конце главы.</p>

<b>Самопроверка</b>
<p>stk-6: Без использования функции activecode infixToPostfix преобразуйте следующее выражение в постфиксню форму: {% highlight Python %}10 + 3 * 5 / (16 - 4){% endhighlight %}</p>

<p>stk-7: {% highlight Python %}17 10 + 3 * 9 / =={% endhighlight %}</p>

<p>stk-8: Модифицируйте функцию infixToPostfix таким образом, чтобы она могла конвертировать следующее выражение: {% highlight Python %}5 * 3 ^ (4 - 2){% endhighlight %}. Вставьте ответ сюда:</p>
