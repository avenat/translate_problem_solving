А сейчас обратим своё внимание на другую линейную структуру данных. Она называется **очередь**. Подобно стекам, очереди относительно просты и также могут использоваться при решении широкого круга важных задач.


## Что такое очередь?


Очередь - это упорядоченная коллекция элементов, в которой добавление новых происходит с одного конца, называемого "хвост очереди", а удаление существующих - с другого, "головы очереди". Как только элемент добавляется в конец очереди, он начинает путь по направлению к её началу, ожидая удаления предыдущих.


Самые последние из добавленных в очередь единиц должны ждать в конце коллекции. Элемент, который пробыл в коллекции дольше всего, находится в начале очереди. Такой принцип упорядочения иногда называют **FIFO, first-in first-out** (*англ. "первый пришёл, первый вышел"*). Ещё он известен, как "первый пришёл - первым обслужен".


Простейший пример такой структуры данных - это обычная очередь, в которой все мы иногда стоим: в кинотеатре, перед кассой в бакалейной лавке, в закусочной (где мы, кстати, можем "выталкивать" поднос из стопки/стека). Правильные очереди очень огранены тем, что имеют только один путь в и один путь из. Для них не предусмотрены прыжки в середину или выход до того, как пройдёт достаточно времени, чтобы переместиться в начало. *Рисунок 1* показывает простую очередь из объектов данных Python.


![Рисунок 1](http://interactivepython.org/runestone/static/pythonds/_images/basicqueue.png" "Рисунок 1: Очередь из объектов данных Python")


Рисунок 1: Очередь из объектов данных Python.


В информатике тоже есть распространённые примеры очередей. В нашей компьютерной лаборатории стоит 30 компьютеров, подключённых по сети к одному принтеру. Когда студенты хотят что-то распечатать, они набирают задание "встать в очередь" вместе со всеми другими ожидающими печати заданиями. Первое задание - следующее, которое будет выполнено. Если вы последний в очереди, то должны ждать, пока напечатаются все стоящие перед вами документы. Позднее мы исследуем этот интересный пример более подробно.


В дополнение к очереди на печать оперативная система использует несколько различных очередей для контроля процессов внутри компьютера. Планирование, что делать следующим, обычно основывается на алгоритме очереди, который пытается запускать программы на выполнение так быстро, как это возможно, и обслуживать максимальное число пользователей. Также иногда в процессе печати на клавиатуре нажатия клавиш опережают появление символов на экране. Это происходит из-за того, что компьютер в этот момент выполняет другую работу. Нажатия клавиш помещаются в очередеподобный буфер, чтобы в конце концов отобразиться на экране в правильном порядке.


## Абстрактный тип данных "очередь"


Абстрактный тип данных для очереди определяется следующими структурой и операциями. Как описывалось выше, очередь структурирована как упорядоченная коллекция элементов, которые добавляются с одного конца, называемого "хвост", и удаляются с другого, называемого "голова". Очередь поддерживает свойство упорядочения FIFO. Операции для очереди представлены ниже.


* ```Queue()``` создаёт новую пустую очередь. Не нуждается в параметрах, возвращает пустую очередь.
* ```enqueue(item)``` добавляет новый элемент в конец очереди. Требует элемент в качестве параметра, ничего не возвращает.
* ```dequeue()``` удаляет передний элемент из очереди. Не нуждается в параметрах, возвращает элемент. Очередь изменяется.
* ```isEmpty()``` проверяет очередь на пустоту. Не нуждается в параметрах, возвращает булево значение.
* ```size()``` возвращает количество элементов в очереди (целое число). Не нуждается в параметрах.


Как пример, если мы предположим, что ```q``` - это очередь, которая создана и пока пуста, то *таблица 1* показывает результаты последовательности операций над нею. Содержимое очереди показано таким образом, что голова находится справа. 4 была первым элементом, ожидающим обработки, поэтому она будет первым элементом, убираемым из очереди.


<table border="1">
  <caption><b>Таблица 1: Пример операций для очереди</b></caption>
  <tr>
    <td><b>Операция</b></td><td><b>Содержимое</b></td><td><b>Возвращаемое значение</b></td>
  </tr>
  <tr>
    <td><code>q.isEmpty()</code></td><td><code>[]</code></td><td><code>True</code></td>
  </tr>
  <tr>
    <td><code>q.enqueue(4)</code></td><td><code>[4]</code></td>
  </tr>
  <tr>
    <td><code>q.enqueue('dog')</code></td><td><code>['dog',4]</code></td>
  </tr>
  <tr>
    <td><code>q.enqueue(True)</code></td><td><code>[True,'dog',4]</code></td>
  </tr>
  <tr>
    <td><code>q.size()</code></td><td><code>[True,'dog',4]</code></td><td><code>3</code></td>
  </tr>
  <tr>
    <td><code>q.isEmpty()</code></td><td><code>[True,'dog',4]</code></td><td><code>False</code></td>
  </tr>
  <tr>
    <td><code>q.enqueue(8.4)</code></td><td><code>[8.4,True,'dog',4]</code></td>
  </tr>
  <tr>
    <td><code>q.dequeue()</code></td><td><code>[8.4,True,'dog']</code></td><td><code>4</code></td>
  </tr>
  <tr>
    <td><code>q.dequeue()</code></td><td><code>[8.4,True]</code></td><td><code>'dog'</code></td>
  </tr>
  <tr>
    <td><code>q.size()</code></td><td><code>[8.4,True]</code></td><td><code>2</code></td>
  </tr>
</table>

## Реализация очереди на Python


Вновь будет подходящим создать новый класс для реализации абстрактного типа данных очереди. Как и раньше, мы будем использовать мощь и простоту коллекции "список" для построения внутреннего представления очереди.


Нам надо определиться, какой конец списках считать головой, а какой - хвостом. Реализация, показанная в *листинге 1* предполагает, что последний элемент очереди находится на нулевой позиции списка. Это позволяет нам использовать функцию ```insert``` для добавления новых элементов в конец очереди. Операция ```pop``` будет использоваться для удаления переднего элемента (последнего элемента в списке). Напомним, что это также означает, что постановка в очередь будет O(n), а извлечение - O(1).


**Листинг 1**


```python
class Queue:
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def enqueue(self, item):
        self.items.insert(0,item)
    def dequeue(self):
        return self.items.pop()
    def size(self):
        return len(self.items)
```


CodeLens 1 демонстрирует класс ```Queue``` в действии для последовательности операций из *таблицы 1*.


**CodeLens: 1 Пример операций очереди**


```python
>>> q.size()
3
>>> q.isEmpty()
False
>>> q.enqueue(8.4)
>>> q.dequeue()
4
>>> q.dequeue()
'dog'
>>> q.size()
2
```


**Самопроверка**


que-1: Предположим, что у вас есть следующая последовательность операций с кодом:


```python
q = Queue()
q.enqueue('hello')
q.enqueue('dog')
q.enqueue(3)
q.dequeue()
```


Какие элементы находятся в очереди слева?


## Симуляция: Hot Potato


Одно из типичных приложений для демонстрации очереди в действии - это симуляция реальной ситуации, которая требует управления данными в манере FIFO. Для начала давайте рассмотрим детскую игру Hot Potato. В этой игре (см. *рисунок 2*) дети выстраиваются в круг и перебрасывают предмет от соседа к соседу так быстро, как только могут. В некоторый момент игры действие останавливается, и ребёнок, у которого остался в руках предмет (картошка), выбывает из круга. Игра продолжается до тех пор, пока не останется единственный победитель.


![Рисунок 2](http://interactivepython.org/runestone/static/pythonds/_images/hotpotato.png "Рисунок 2: Игра Hot Potato с шестью игроками")

Рисунок 2: Игра Hot Potato с шестью игроками.


Эта игра - современный вариант знаменитой [считалки Джозефуса](http://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%98%D0%BE%D1%81%D0%B8%D1%84%D0%B0_%D0%A4%D0%BB%D0%B0%D0%B2%D0%B8%D1%8F). Основываясь на легенде о знаменитом историке первого века Иосифе Флавии, история рассказывает, что когда евреи восстали против Рима, Иосиф и 39 его товарищей оборонялись против римлян в пещере. Осознав, что поражение неизбежно, они решили, что лучше умереть, чем стать рабами империи. Воины встали в круг, и один из них был назначен первым номером. Затем, следуя по часовой стрелке, они убивали каждого седьмого. Иосиф, как говорит легенда, кроме всего прочего был прекрасным математиком. Он сразу сообразил, где нужно встать, чтобы оказаться последним. Когда подошло время, то вместо того, чтобы убить себя, он перешёл на сторону римлян. Вы можете найти множество различных версий этой истории. Одни считают каждого третьего человека, а другие полагают, что последний мог сбежать на лошади. В любом случае, идея остаётся прежней.


Мы реализуем общую **симуляцию** игры Hot Potato. Наша программа будет получать на входе список имён и константу "num", используемую для подсчёта. Она будет возвращать имя последнего человека, оставшегося после повторяющегося отсчёта ```num```. Что случится в этот момент - зависит уже от вас.


Для симуляции круга мы будем использовать очередь (см. *рисунок 3*). Предположим, что ребёнок, держащий картошку, - первый в очереди. После переброса картошки мы просто извлечём его оттуда и тут же поставим обратно, но уже в хвост. Ребёнок будет ждать, пока все, кто перед ним, побудут первыми, а затем вернётся на это место снова. После ```num``` операций извлечений/постановок ребёнок, стоящий впереди, будет удалён окончательно, и цикл начнётся заново. Этот процесс будет продолжаться до тех пор, пока не останется всего одно имя (размер очереди станет равным 1).


![Рисунок 3](http://interactivepython.org/runestone/static/pythonds/_images/namequeue.png "Рисунок 3: Реализация Hot Potato в виде очереди")

Рисунок 3: Реализация Hot Potato в виде очереди


Программа показана в *ActiveCode 1*. Вызов функции ```hotPotato```, использующий 7 в качестве константы для подсчёта, возвращает ```Susan```.


**Active Code: 1** Симуляция Hot Potato


Обратите внимание, что в этом примере значение константы подсчёта больше количества имён в списке. Это не является проблемой, поскольку очередь работает как круг и продолжает считать с начала до тех пор, пока не будет достигнуто нужное значение. Также заметьте, что список загружается в очередь таким образом, чтобы его первое имя было в её начале. В данном случае первым элементом в списке будет ```Bill```, поэтому он помещается в начало очереди. Варианты этой реализации, описанные в упражнениях, позволяют выбирать счётчик случайным образом.


## Симуляция: Задания на печать


Более интересная симуляция позволит нам изучить поведение очереди на печать, описанной ранее в этом разделе. Напомним, что когда студенты отправляют документы для печати на общем принтере, то задания помещаются в очередь, чтобы быть обработанными в манере "первым пришёл - первым обслужен". В связи с такого рода конфигурацией возникает много вопросов. Возможно, наиболее важный из них: способен ли принтер обработать определённое количество документов? Если нет, то студенты будут ждать чересчур долго и могут пропустить своё следующее занятие.


Рассмотрим такую ситуацию в лаборатории информатики. В любой среднестатистический день в любой час в лаборатории работает порядка 10 студентов. В течение этого времени они обычно печатают дважды, причём длина задания варьируется от одной до двадцати страниц. Принтер в лаборатории стар и в черновом качестве способен обрабатывать всего 10 страниц в минуту. Можно переключить его на лучшее качество печати, но тогда производительность упадёт до 5 страниц/мин. Низкая скорость печати заставляет студентов ждать слишком долго. Какую скорость для страниц следует использовать?


Мы можем определить это, построив симуляционную модель лаборатории. Нам потребуется создать представления студентов, заданий на печать и принтера (*рисунок 4*). Когда студенты подают документы на печать, мы будем добавлять их в список ожидания - очередь заданий на печать, прикреплённую к принтеру. Когда принтер заканчивает очередное задание, он смотрит в очередь на предмет наличия оставшихся документов для обработки. Интерес для нас представляет среднее время ожидания задачи в очереди.

![Рисунок 4](http://interactivepython.org/runestone/static/pythonds/_images/simulationsetup.png "Рисунок 4: Очередь на печать в лаборатории информатики")

Рисунок 4: Очередь на печать в лаборатории информатики


Для моделирования этой ситуации нам нужно использовать некоторые вероятности. Например, студенты могут печатать документы величиной от одной до двадцати страниц. Если каждая длина от 1 до 20 одинаково возможна, то текущий размер задания на печать можно симулировать, используя случайное число от 1 до 20 включительно. Это означает, что шансы возникновения документа любой длины от 1 до 20 равны.


Если в лаборатории находятся десять студентов и каждый из них печатает дважды, то в среднем в час будет 20 заданий на печать. Какова вероятность, что в любую заданную секунду одно из них будет создано? Способ ответить на этот вопрос - рассмотреть отношение количества заданий к времени. Двадцать заданий на час означают одно задание на каждые 180 секунд:


<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mfrac>
    <mrow>
      <mn>20</mn>
      <mtext>&#xA0;</mtext>
      <mi>t</mi>
      <mi>a</mi>
      <mi>s</mi>
      <mi>k</mi>
      <mi>s</mi>
    </mrow>
    <mrow>
      <mn>1</mn>
      <mtext>&#xA0;</mtext>
      <mi>h</mi>
      <mi>o</mi>
      <mi>u</mi>
      <mi>r</mi>
    </mrow>
  </mfrac>
  <mo>&#x00D7;<!-- × --></mo>
  <mfrac>
    <mrow>
      <mn>1</mn>
      <mtext>&#xA0;</mtext>
      <mi>h</mi>
      <mi>o</mi>
      <mi>u</mi>
      <mi>r</mi>
    </mrow>
    <mrow>
      <mn>60</mn>
      <mtext>&#xA0;</mtext>
      <mi>m</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mi>s</mi>
    </mrow>
  </mfrac>
  <mo>&#x00D7;<!-- × --></mo>
  <mfrac>
    <mrow>
      <mn>1</mn>
      <mtext>&#xA0;</mtext>
      <mi>m</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mi>u</mi>
      <mi>t</mi>
      <mi>e</mi>
    </mrow>
    <mrow>
      <mn>60</mn>
      <mtext>&#xA0;</mtext>
      <mi>s</mi>
      <mi>e</mi>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>d</mi>
      <mi>s</mi>
    </mrow>
  </mfrac>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mn>1</mn>
      <mtext>&#xA0;</mtext>
      <mi>t</mi>
      <mi>a</mi>
      <mi>s</mi>
      <mi>k</mi>
    </mrow>
    <mrow>
      <mn>180</mn>
      <mtext>&#xA0;</mtext>
      <mi>s</mi>
      <mi>e</mi>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>d</mi>
      <mi>s</mi>
    </mrow>
  </mfrac>
</math>


Для каждой секунды мы можем симулировать вероятность появления задания путём генерации случайного числа между 1 и 180 включительно. Если число равно 180, то мы говорим, что задание создано. Заметьте, что возможно создание множества заданий одного за другим или наоборот - мы можем ждать долгое время, пока что-то появится. Такова природа моделирования. Вы хотите симулировать реальную ситуацию настолько близко к реальности, насколько это возможно, учитывая всё, что знаете об общих параметрах.


### Основные шаги симуляции


Вот основная модель:


1. Создать очередь из заданий на печать. Каждое из них будет иметь отметку о времени постановки в очередь. В самом начале очередь пуста.
2. Для каждой секунды (```currentSecond```):
    * Создано ли новое задание на печать? Если да, то добавить его в очередь с ```currentSecond``` в качестве отметки времени.
    * Если принтер не занят и есть ожидающее задание, то
        * Удалить следующее задание из очереди на печать и передать его принтеру.
        * Извлечь отметку о времени из ```currentSecond```, чтобы вычислить время ожидания для данного задания.
        * Добавить время ожидания этой задачи в список для дальнейшей обработки.
        * Основываясь на количестве страниц в задании на печать, вычислить, сколько для него потребуется времени.
    * Если необходимо, принтер тратит одну секунду печати. Также он вычитает её из времени, необходимого для выполнения задачи.
    * Если задание завершено (другими словами, требуемое на его выполнение время равно нулю), то принтер более не занят.
3. После завершения симуляции вычисляется среднее время ожидания из сгенерированного списка времён ожидания.


### Реализация на Python


Для этой симуляции мы создадим классы трёх объектов реального мира, описанных выше: ```Printer```, ```Task``` и ```PrintQueue```.


Классу ```Printer``` (*листинг 2*) будет необходима возможность отслеживать, имеет ли он текущую задачу. Если да, то он занят (строки 13-17), и необходимо вычислить временнЫе затраты, исходя из количества страниц в задании. Так же конструктор позволяет инициализировать настройку количества печатаемых в минуту страниц. Метод ```tick``` уменьшает на единицу внутренний таймер и устанавливает холостой ход принтера (строка 11), если задание выполнено.


**Листинг 2**


```python
class Printer:
    def __init__(self, ppm):
        self.pagerate = ppm
        self.currentTask = None
        self.timeRemaining = 0
    def tick(self):
        if self.currentTask != None:
            self.timeRemaining = self.timeRemaining - 1
            if self.timeRemaining <= 0:
                self.currentTask = None
    def busy(self):
        if self.currentTask != None:
            return True
        else:
            return False
    def startNext(self,newtask):
        self.currentTask = newtask
        self.timeRemaining = newtask.getPages() * 60/self.pagerate
```


Класс заданий (*листинг 3*) будет представлять единичное задание для печати. Когда оно создаётся, генератор случайных чисел предоставляет его длину в диапазоне от 1 до 20 страниц. Мы выбрали использование функции ```randrange``` из модуля ```random```.


```python
>>> import random
>>> random.randrange(1,21)
18
>>> random.randrange(1,21)
8
>>>
```


Так же каждое задание нуждается в отметке, которая будет использоваться для подсчёта времени ожидания. Она будет представлять из себя момент, когда задание было создано и помещено в очередь принтера. Затем может быть использован метод ```waitTime``` для извлечения времени, затраченного на ожидание в очереди начала печати.


**Листинг 3**


```python
import random

class Task:
    def __init__(self,time):
        self.timestamp = time
        self.pages = random.randrange(1,21)
    def getStamp(self):
        return self.timestamp
    def getPages(self):
        return self.pages
    def waitTime(self, currenttime):
        return currenttime - self.timestamp
```

Основная симуляция (*листинг 4*) реализует алгоритм, описанный выше. Объект ```printQueue``` представляет собой экземпляр нашего существующего АТД очереди. Вспомогательная булева функция ```newPrintTask``` определяет, было ли создано новое задание на печать. Мы вновь выбрали функцию ```randrange``` из модуля ```random```, чтобы возвращать случайное целое из диапазона от 1 до 180. Задания на печать появляются раз в каждые 180 секунд. Произвольно выбрав 180 из диапазона целых чисел (строка 32), мы можем симулировать это случайное событие. Функция симуляции позволяет нам установить для принтера общее время и количество страниц в минуту.


**Листинг 4**


```python
from pythonds.basic.queue import Queue
import random
def simulation(numSeconds, pagesPerMinute):
    labprinter = Printer(pagesPerMinute)
    printQueue = Queue()
    waitingtimes = []
    for currentSecond in range(numSeconds):
      if newPrintTask():
         task = Task(currentSecond)
         printQueue.enqueue(task)
      if (not labprinter.busy()) and (not printQueue.isEmpty()):
        nexttask = printQueue.dequeue()
        waitingtimes.append(nexttask.waitTime(currentSecond))
        labprinter.startNext(nexttask)
      labprinter.tick()
    averageWait=sum(waitingtimes)/len(waitingtimes)
    print("Average Wait %6.2f secs %3d tasks remaining."%(averageWait,printQueue.size()))
def newPrintTask():
    num = random.randrange(1,181)
    if num == 180:
        return True
    else:
        return False
for i in range(10):
    simulation(3600,5)
```

Когда мы запускаем симуляцию, нас не должно беспокоить, что результаты каждый раз будут разными. Это заложено в вероятностную природу случайных чисел. Нас интересуют тенденции, которые появляются при корректировке параметров симуляции. Вот некоторые результаты.


В первый раз мы запускаем симуляцию для периода в 60 минут (3600 секунд), используя скорость печати 5 страниц в минуту. Дополнительно мы проводим 10 независимых попыток. Помните, что поскольку симуляция работает со случайными числами, то на каждом запуске мы получим разные результаты.


```python
>>>for i in range(10):
      simulation(3600,5)

Average Wait 165.38 secs 2 tasks remaining.
Average Wait  95.07 secs 1 tasks remaining.
Average Wait  65.05 secs 2 tasks remaining.
Average Wait  99.74 secs 1 tasks remaining.
Average Wait  17.27 secs 0 tasks remaining.
Average Wait 239.61 secs 5 tasks remaining.
Average Wait  75.11 secs 1 tasks remaining.
Average Wait  48.33 secs 0 tasks remaining.
Average Wait  39.31 secs 3 tasks remaining.
Average Wait 376.05 secs 1 tasks remaining.
```


После запуска наших десяти попыток мы видим, что среднее время ожидания составляет 122,155 секунд. Так же заметен большой разброс средних весов времени от 17,27 до максимальных 376,05 секунд. Обратите внимание, что задания завершили выполнение всего в двух случаях.


А теперь установим скорость печать на 10 страниц в минуту и вновь запустим 10 попыток. С большей скоростью мы можем надеяться выполнить больше заданий в рамках одного часа.


```python
>>>for i in range(10):
      simulation(3600,10)

Average Wait   1.29 secs 0 tasks remaining.
Average Wait   7.00 secs 0 tasks remaining.
Average Wait  28.96 secs 1 tasks remaining.
Average Wait  13.55 secs 0 tasks remaining.
Average Wait  12.67 secs 0 tasks remaining.
Average Wait   6.46 secs 0 tasks remaining.
Average Wait  22.33 secs 0 tasks remaining.
Average Wait  12.39 secs 0 tasks remaining.
Average Wait   7.27 secs 0 tasks remaining.
Average Wait  18.17 secs 0 tasks remaining.
```


Вы можете запустить симуляцию самостоятельно в ActiveCode 2.


**ActiveCode: 2** Симуляция очереди принтера


### Обсуждение


Мы пытались ответить на вопрос о том, может ли текущий принтер обработать загруженное задание, если установлена печать лучшего качества, но с более низкой скоростью. Подход, который мы использовали для написания симуляции, моделировал задания на печать как случайные события различной длины и времени появления.


Вывод выше показывает, что с пятью страницами в минуту среднее время ожидания варьируется от 17 до 376 секунд (около шести минут). С более высокой скоростью печати нижним значением становится одна секунда, а верхним - всего 28. Более того, в 8 из 10 запусков при 5 страниц/мин по истечение часа в очереди остаются ожидающие задания.


Таким образом, мы, возможно, убедились, что снижение скорости печати в пользу улучшения качества - не самая лучшая идея. Студенты не могут позволить себе так долго ждать свои документы, особенно когда им надо спешить на следующую пару. Шестиминутное ожидание будет просто чересчур долгим.


Такой тип анализа симуляции позволяет нам ответить на множество вопросов, в целом известных как "что, если?". Всё, что нужно - это менять параметры, используемые для симуляции, и тогда мы можем моделировать любое количество интересных случаев. Например,


+ Что, если возрастёт среднее число принятых заявок на печать, а среднее количество студентов увеличится до 20 человек?
+ Что, если сегодня суббота, и студентам не нужно идти на занятия? Могут ли они позволить себе ожидание?
+ Что, если размер среднего задания на печать уменьшится, поскольку Python - очень мощный язык, и программы на нём имеют тенденцию становиться короче?


На все эти вопросы можно ответить, модифицируя симуляцию выше. Однако, важно помнить, что модель хороша настолько, насколько хороши допущения, на которых она построена. Для создания надёжной модели были необходимы настоящие данные о числе заданий на печать и количестве студентов в час.


**Самопроверка**


Как бы вы модифицировали симуляцию принтера, чтобы отразить большее число студентов? Предположим, что оно удвоилось. Вам необходимо сделать некоторые разумные допущения о том, как связать это с данной моделью. Что бы вы изменили? Модифицируйте код. Также предположите, что длина среднего задания на печать уменьшилась в половину. Измените код, чтобы отразить это. Наконец, как бы вы параметризировали количество студентов? Вместо того, чтобы каждый раз изменять код, мы бы предпочли просто задавать число студентов параметром симуляции.


**ActiveCode: 3**
