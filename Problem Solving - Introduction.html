Цели
===


* Обзор понятий "информатика", "программирование" и "решение проблем"
* Понять, что значит "абстракция", и какую роль она играет в процессе решения проблемы
* Понять и воплотить идею абстрактного типа данных</li>
* Обзор языка программирования Python


Приступая к работе
===
Наше восприятие программирования претерпело множество изменений за годы, прошедшие с момента появления первых электронных компьютеров, требовавших жгуты соединительных кабелей и массу переключателей, чтобы передавать простейшие инструкции от человека к машине. Как и в случае со многими аспектами человеческого общества, изменения в области вычислительных технологий предоставили учёным - информатикам огромное количество инструментов и платформ для практики своего ремесла. Прогресс в лице более быстрых процессоров, высокоскоростных сетей и больших объёмов памяти создал спираль сложности, в которой учёные должны свободно ориентироваться. Но на всём этом крутом эволюционном пути некоторое количество базовых принципов остаётся неизменным.Вычислительные науки тесно связаны с использованием вычислителей (компьютеров) для решения задач.

Вы наверняка потратили много времени на изучение основ методики решения задач и, надеюсь, умеете уверенно формулировать вопросы и разрабатывать для них решения. Вы так же хорошо усвоили, что писать компьютерные программы часто совсем не легко. Сложность больших задач и связанная с нею сложность их решений имеют тенденцию перекрывать фундаментальные идеи, связанные с собственно процессом решения.

В этой главе мы выделим две важные области, которые будут подробно рассматриваться в дальнейшем тексте. Во-первых, структуру, рамкам которой должны соответствовать теория информатики и изучение алгоритмов и структур данных. В частности, упомянем о причинах, почему эту тему стоит изучать и как её понимание помогает лучше решать возникающие задачи. Во-вторых, мы рассмотрим язык программирования Python. Не смотря на то, что мы не можем предоставить детальные, исчерпывающие ссылки, мы приведём примеры и объяснения основных конструкций и идей, с которыми нам предстоит встретиться в последующих главах.

Что такое информатика?
===
Очень часто сложно дать определение понятию "computer science". Может быть, причиной этого является неудачное использование в названии слова "computer". Как вы возможно знаете, информатика - это не только изучение компьютеров. Хотя они и играют важную вспомогательную роль в данной дисциплине, но всё равно остаются всего лишь инструментами.

Информатика занимается изучением задач, процессом их решения и получившимися результатами. Для каждой поставленной задачи учёный-информатик должен разработать **алгоритм** - пошаговую инструкцию для получения решения любого её частного случая, который только может возникнуть. Алгоритм считается законченным, если следование ему приводит к решению проблемы. Алгоритм и есть это решение.

Информатику можно рассматривать как науку, исследующую алгоритмы. Однако, нам стоит быть осторожнее, принимая во внимание тот факт, что некоторые задачи могут и не иметь решения. Хотя доказательство этого положения выходит за пределы данной книги, сам факт, что не все задачи можно решить, очень важен для решившего заняться изучением информатики. Мы сможем полностью сформулировать понятие "информатика" только включив в него оба типа задач и положив, что эта наука занимается изучением как решаемых задач, так тех, что решения не имеют.

Так же при описании задач и их решений часто встречается слово **"вычислимый"**. Мы говорим, что задача вычислима, если существует алгоритм для её решения. Таким образом, можно сформулировать альтернативное определение информатики, как науки, занимающейся изучением вычислимых и не вычислимых задач, существующих и не существующих алгоритмов. В любом случае, вы легко можете заметить, что слово "компьютер" здесь нигде не употребляется. Решение рассматривает независимо от машины.

Информатика, имея отношение к процессу решения различных задач, также занимается изучением абстракций. Абстракция позволяет нам рассматривать задачу и её решение, разделяя так называемые логический и физический ракурсы. Основа этой идеи знакома нам по широко распространённому примеру.

Рассмотрим автомобиль, который, возможно, ежедневно отвозит вас в школу или на работу. Как водитель (пользователь автомобиля) вы определённым образом взаимодействуете с машиной, чтобы использовать её по прямому назначению. Вы садитесь, вставляете ключ зажигания, заводите машину, переключаете передачи, тормозите, жмёте на газ и крутите руль в процессе езды. С абстрактной точки зрения мы можем сказать, что вы рассматриваете автомобиль с логического ракурса. Вы используете набор функций, предоставленный вам конструкторами автомобиля, с целью перемещения себя из пункта А в пункт Б. Эти функции так же иногда называют **интерфейсом**.

С другой стороны, механик, который должен чинить ваш автомобиль, имеет абсолютно другой взгляд на него. Ему нужно не только знать, как управлять машиной, но и быть в курсе всех подробностей тех функций, которые мы воспринимаем как должные. Например, как работают двигатель и коробка передач, контролируется температура и тому подобное. Этот подход известен как "физический ракурс" - детали, лежащие "под капотом".

Тоже самое имеет место и при использовании компьютера. Большинство людей используют компьютер, чтобы писать документы, отправлять и получать почты, сёрфить в интернете, проигрывать музыку, хранить картинки и играть в игры, не имея при этом ни малейшего представления о деталях работы всех этих приложений. Они смотрят на компьютер с логической (или пользовательской) точки зрения. Учёные-информатики, программисты, персонал технической поддержки и системные администраторы имеют совершенно другое в<i>и</i>денье компьютера. Они должны знать детали того, как работает операционная система, настраиваются сетевые протоколы, пишутся скрипты для выполнения тех или иных функций. Они должны быть готовы управлять всеми низкоуровневыми деталями, которые для пользователей подразумеваются сами собой.

Общим в этих двух примерах является то, что пользователю абстракции (иногда его называют "клиентом") нет необходимости знать детали до тех пор, пока интерфейс нормально работает. Этот интерфейс - способ, которым мы как пользователи общаемся с лежащей в глубине сложностью реализации. Как ещё один пример абстракции можно рассмотреть модуль ```math``` языка Python. Единожды импортировав модуль, мы можем совершать вычисления вида:

>>> import math
>>> math.sqrt(16)
4.0
>>>

Это пример **процедурной абстракции**. Нам не нужно знать, как будет вычислен квадратный корень, - достаточно информации о том, какую функцию нужно вызвать и как её использовать. Если мы осуществили корректный вызов, то можем смело полагать, что получим корректный же результат. Мы знаем, что кто-то реализовал нахождение квадратного корня, но всё что нам по-настоящему необходимо - это знать как его использовать. Такой подход иногда называют "чёрным ящиком". Мы просто описываем интерфейс: имя функции, её параметры и результат. Детали же скрыты внутри (см. _рисунок 1_).

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/blackbox.png" align="middle"></p>
<p align="middle">Рисунок 1: Процедурная абстракция</p>

Что такое программирование?
===
**Программирование** - это процесс превращения алгоритма в нотацию, написанную на языке программирования, которая может быть выполнена компьютером. Несмотря на существование большого количества различных языков программирования и типов компьютеров, самый первый и важный шаг - это иметь решение. Без алгоритма никакой программы быть не может.

Информатика - это не наука о программировании. Однако, программирование - важная часть того, чем занимаются учёные-информатики. Часто программирование для нас - это способ создать представление найденного решения. Вот почему воплощение в языке и процесс его создания являются фундаментальной частью дисциплины.

Алгоритмы описывают решение задачи в терминах данных, необходимых для представления сущностей задачи, и набора шагов, нужных для получения конечного результата. Язык программирования должен предоставить способ для записи их обоих - данных и процесса.Для этой цели в языках предусмотрены типы данных и управляющие конструкции.

Управляющие конструкции позволяют шагам алгоритма воплотиться подходящим и однозначным образом. Как минимум алгоритму требуются конструкции для последовательной обработки, отбора с целью принятия решения и итераций для повторяющегося управления. Пока язык предоставляет эти основные положения, он может использоваться для реализации алгоритмов.

Все элементы данных представляются в компьютере как последовательности из нулей и единиц. Для того, чтобы придать смысл этим последовательностям, нам нужны типы данных. Они предоставляют интерпретацию бинарных данных, благодаря которой мы можем думать о данных в терминах, имеющих смысл по отношению к решаемой задаче. Эти низкоуровневые встроенные типы данных (иногда называемые примитивными) обеспечивают строительные блоки для разработки алгоритмов.

Например, большинство языков программирования предлагают тип данных для целых чисел. Строки бинарных цифр в памяти компьютера могут быть интерпретированы как целые числа, с учётом тех характерных смыслов, которые мы обычно с ними ассоциируем (например, 23, 654 или -19). Кроме того, типы данных также предоставляют описание операций, в которых могут принимать участие их элементы. Для целых чисел такими операциями обычно являются сложение, вычитание и умножение. Мы закономерно ожидаем, что числовые типы данных могут участвовать в этих арифметических операциях.

Часто возникающая у нас трудность заключается в том факте, что задачи и их решения очень сложны. Простые, предлагаемые языком конструкции и типы данных (которых, конечно, бывает достаточно для представления сложного решения) как правило невыгодно использовать в процессе поиска решения. Нам нужны способы управлять этой сложностью и помогать с созданием решения.

Для чего изучать структуры и абстрактные типы данных?
---

<p>Чтобы управлять сложностью задач и процессом их решения, учёные-информатики используют абстракции, позволяющие им сфокусироваться на картине в целом, без блуждания в деталях. Создавая модель предметной области, мы можем использовать лучший и более эффективный процесс поиска решения. Такие модели позволяют нам описывать данные, которыми будут манипулировать наши алгоритмы, намного более подходящим для данной задачи образом.</p>

Ранее мы ссылались на процедурную абстракцию, как на процесс сокрытия деталей конкретной функции, чтобы дать пользователю (или клиенту) возможность рассматривать её на очень высоком уровне. Сейчас мы переключаем наше внимание на аналогичную идею **абстракции данных**. **Абстрактный тип данных**, иногда обозначаемый аббревиатурой **АТД**, это логическое описание того, как мы рассматриваем данные и разрешённые для них операции, безотносительно их реализации. Это значит, что мы сосредотачиваемся только на том, что данные из себя представляют, а не на том, как они в итоге будут сконструированы. Обеспечивая такой уровень абстракции, мы достигаем **инкапсуляции данных**. Идея здесь в том, что, инкапсулируя детали реализации, мы скрываем их от взгляда пользователя. Это называется **сокрытием информации**.

**Рисунок 2** наглядно демонстрирует, что такое абстрактный тип данных и как он работает. Пользователь взаимодействует с интерфейсом, используя операции, определённые в абстрактном типе данных. По сути, абстрактный тип данных - это оболочка, с которой контактирует клиент. Реализация скрыта на уровень ниже, и её детали совершенно не беспокоят пользователя.

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/adt.png" align="middle"></p>
<p align="middle">Рисунок 2: Абстрактный тип данных</p>

Реализация абстрактного типа данных, часто называемая **структурой данных**, требует, чтобы мы смотрели на данные с физической точки зрения, используя при этом некий набор из конструкций программирования и примитивных типов данных. Как мы уже обсуждали ранее, разделение этих двух точек зрения приводит нас к определению сложных моделей данных для наших задач без углубления в подробности того, как эти модели в итоге будут реализованы. Так обеспечивается **независящий от реализации** взгляд на данные. Так как обычно существует множество различных способов воплотить абстрактный тип данных, независимость реализации позволяет программисту изменять её детали, не меняя при этом способа взаимодействия пользователя с данными. Таким образом, пользователь остаётся сфокусированным только на процессе решения задачи.

Для чего изучать алгоритмы?
---
Учёные - информатики учатся на собственном опыте - глядя, как другие решают задачи, и решая их самостоятельно. Применение различных методологий для поиска решения и рассмотрение конструкций алгоритмов помогает нам справляться с последующими сложными задачами, за которые мы берёмся. Рассмотрев некоторое количество различных алгоритмов, мы можем приступить к разработке шаблона для распознавания, чтобы, когда похожая проблема возникнет в следующий раз, быть лучше подготовленными к её решению.

Алгоритмы часто сильно отличаются друг от друга. Рассмотрим пример с ```sqrt```, к которому мы прибегали ранее. Вполне возможно, что существует множество различных способов реализации деталей вычисления квадратного корня. Один алгоритм может использовать для этого много меньше ресурсов, другой - работать до получения результата в десять раз дольше, и тому подобное. Мы бы хотели иметь возможность сравнивать эти два решения. Хотя они оба работают, одно из них, возможно, "лучше", чем другое. Мы можем предположить, что оно более эффективно или просто работает быстрее, занимая меньше памяти. Как мы изучаем алгоритмы, так можем и изучать аналитические техники, позволяющие сравнивать и противопоставлять решения, основываясь исключительно на их собственных характеристиках, а не на характеристиках программ или компьютеров, используемых для их реализации.

В самом наихудшем случае мы можем столкнуться с труднообрабатываемой проблемой, что означает невозможность решить её за разумное количество времени. Очень важно уметь различать задачи, имеющие решение, не имеющие такового и те, для которых решение существует, но занимает чересчур много времени или других ресурсов, чтобы его использование было разумным.

Здесь часто нужен компромисс, который необходимо видеть и принимать по нему решение. Как учёным-информатикам, в дополнение к нашим способностям находить решение, нам нужно также знать и понимать техники его вычисления. В конце-концов, очень часто существует множество способов решить проблему. Найти решение и убедиться, что оно хорошо, - вот задача, над которой мы работаем снова и снова.


Обзор основ Python
===

В этом разделе мы дадим обзор языка программирования Python и заодно предоставим несколько более детальных примеров идей, сформулированных выше. Если вы новичок в Python или считаете, что вам нужно больше информации по любой из представленных здесь тем, то мы рекомендуем вам получить консультацию на ресурсах <a href="http://docs.python.org/3/reference/index.html">Python Language Reference</a> или <a href="http://docs.python.org/3/tutorial/index.html">Python Tutorial</a>. Нашей целью в этом разделе является повторное ознакомление вас с языком, а также усиление понимания некоторых концепций, которые займут центральное место в последующих главах.

<p>Python является современным объектно-ориентированным языком программирования с низким порогом вхождения. Он обладает мощным набором встроенных типов данных и легких в использовании управляющих конструкций. Поскольку Python - интерпретируемый язык программирования, то проще всего знакомиться с ним рассматривая и описывая интерактивные сессии. Вы должны помнить, что интерпретатор сначала выдаёт знакомое приглашение ввода <code>>>></code>, а затем вычисляет предоставленную вами Python-конструкцию. Например:</p>

```python
>>> print("Algorithms and Data Structures")
Algorithms and Data Structures
>>>
```

покажет приглашение, функцию ```print```, результат её выполнения и следующее приглашение.

Приступая к работе с данными
---
Выше мы уже отмечали, что Python поддерживает парадигму объектно-ориентированного программирования. Это означает, что в фокус процесса решения задачи Python ставит данные. В Python, как и в любом другом объектно-ориентированном языке программирования, мы определяем **класс**, являющийся описанием того, как, собственно, выглядят данные (состояние) и что они могут делать (поведение). Классы аналогичны абстрактным типам данных, поскольку пользователь класса видит только состояние и поведение единицы данных. Такие единицы в объектно-ориентированной парадигме называются **объектами**. Объект является экземпляром класса.

Встроенные элементарные типы данных
---

<p>Начнём наш обзор с рассмотрения элементарных типов данных. У Python есть два основных встроенных числовых класса, реализующих типы для целых чисел и чисел с плавающей запятой. Они называются ```int``` и ```float```. Стандартные арифметические операции ```+```, ```-```, ```*```, ```/``` и ```**``` (возведение в степень) могут использоваться со скобками, задающими порядок операций, отличный от обусловленного обычным приоритетом операторов. Другими полезными операциями являются оператор остатка целочисленного деления <code>%</code> и собственно целочисленного деления <code>//</code>. Обратите внимание, что при делении двух целых чисел результат - число с плавающей запятой. Оператор целочисленного деления возвращает целую часть частного путём отсечения от неё дробной части.</p>

<p align="middle"><b>Active Code: 1</b> Основные арифметические операторы</p>

<p>Логический тип данных, реализованный в Python как класс <code>bool</code>, будет весьма полезен для представления значений истинности. Возможными значениями для логического объекта являются <code>True</code> и <code>False</code> со стандартными булевыми операторами <code>and</code>, <code>or</code> и <code>not</code>.</p>

<pre>>>> True
True
>>> False
False
>>> False or True
True
>>> not (False or True)
False
>>> True and True
True</pre>

<p>Объекты булева типа данных также используются в качестве результатов операций сравнения, таких как "равно" (==) и "больше, чем" (>). Кроме того, операторы отношений и логических операций могут быть скомбинированы вместе в форме сложных логических вопросов. В <i>таблице 1</i> показаны операторы отношений и логические операторы вместе с примерами их использования.</p>

<table align="middle" border='1'>
<caption>Таблица 1: Логические операторы и операторы отношений</caption>
<thead><td>Название</td><td>Оператор</td><td>Описание</td></thead>
<tr><td>меньше</td><td>&lt</td><td>Оператор "меньше"</td></tr>
<tr><td>больше</td><td>&gt</td><td>Оператор "больше"</td></tr>
<tr><td>меньше или равно</td><td>&lt=</td><td>Оператор "меньше или равно"</td></tr>
<tr><td>больше или равно</td><td>&gt=</td><td>Оператор "больше или равно"</td></tr>
<tr><td>равно</td><td>==</td><td>Оператор равенства</td></tr>
<tr><td>неравно</td><td>!=</td><td>Оператор неравенства</td></tr>
<tr><td>логическое "и"</td><td>and</td><td>Если оба операнда истинны, то результат тоже истина</td></tr>
<tr><td>логическое "или"</td><td>or</td><td>Если хотя бы один из операндов истина, то результат - истина</td></tr>
<tr><td>логическое "не"</td><td>not</td><td>Инвертирует значение: False становится True и наоборот</td></tr>
</table>

<p align="middle"><b>Active Code: 2</b> Основные логические операторы и операторы отношений</p>

<p>В качестве имён в языках программирования используются идентификаторы. В Python они начинаются с буквы или подчёркивания (_), чувствительны к регистру и могут быть произвольной длины. Не забывайте о том, что давать имена, отражающие смысл переменной, - всегда здравая идея, делающая ваш код более простым для чтения и понимания.</p>

<p>В Python переменная создаётся при первом использовании имени с левой стороны от оператора присваивания. Присваивание предоставляет возможность ассоциировать имя со значением. Переменная будет содержать ссылку на кусочек данных, а не сами данные. Рассмотрим следующий код:</p>

<pre>>>> theSum = 0
>>> theSum
0
>>> theSum = theSum + 1
>>> theSum
1
>>> theSum = True
>>> theSum
True</pre>

<p>Присваивание <code>theSum = 0</code> создаёт переменную с именем <code>theSum</code>, содержащую ссылку на объект данных <code>0</code> (см. <i>рисунок 3</i>). В целом, когда правая часть оператора присваивания вычисляется, ссылка на результат "назначается" имени в левой части. В данный момент в нашем примере тип переменной - целое, и это тип данных, на которые сейчас ссылается <code>theSum</code>. Если он изменится (см. <i>рисунок 4</i>), как показано выше, на булево значение <code>True</code>, то изменится и тип переменной (сейчас <code>theSum</code> имеет тип <code>bool</code>). Оператор присваивания меняет ссылки, хранящиеся в переменной. Это динамическая характеристика Python. Одна и та же переменная может ссылаться на различные типы данных.</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/assignment1.png" align="middle"></p>
<p align="middle">Рисунок 3: Переменная содержит ссылку на объект данных</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/assignment2.png" align="middle"></p>
<p align="middle">Рисунок 4: Присваивание изменяет ссылку</p>

<h3>Встроенные составные типы данных</h3>
<p>Кроме числовых и булева типов данных у Python есть несколько мощных встроенных составных классов. Списки, строки и кортежи являются упорядоченными коллекциями. Они весьма схожи по общей структуре, но имеют специфические различия, понимать которые необходимо для уместного их использования. К неупорядоченным коллекциям относятся множества и словари.</p>
<p><b>Список</b> - это упорядоченная коллекция из нуля или более ссылок на объекты данных Python. Списки записываются как разделённые запятыми значения, заключённые в квадратные скобки. Пустой список выглядит просто <code>[]</code>. Списки гетерогенны. Это означает, что их объекты не обязательно должны иметь один и тот же тип, и коллекция может быть присвоена переменной, как показано ниже. Следующий фрагмент показывает различные объекты данных Python, объединённые в список.</p>

<pre>>>> [1,3,True,6.5]
[1, 3, True, 6.5]
>>> myList = [1,3,True,6.5]
>>> myList
[1, 3, True, 6.5]</pre>

<p>Обратите внимание, что результатом вычисления списка в Python является он сам. Тем не менее, чтобы запомнить список для последующей обработки, ссылка на него должна быть присвоена переменной.</p>

<p>Поскольку списки считаются последовательно упорядоченными, то они поддерживают ряд операций, которые могут быть применены к любой Python-последовательности. Эти операции собраны в <i>таблице 2</i> вместе с примерами их использования.</p>

<table align="middle" border='1'>
<caption>Таблица 2: Операции для любой последовательности в Python</caption>
<thead><td>Название</td><td>Оператор</td><td>Пояснение</td></thead>
<tr><td>индексирование</td><td>[]</td><td>Доступ к элементу последовательности</td></tr>
<tr><td>конкатенация</td><td>+</td><td>Объединение двух последовательностей</td></tr>
<tr><td>повторение</td><td>*</td><td>Конкатенация повторений заданное количество раз</td></tr>
<tr><td>принадлежность элемента</td><td>in</td><td>Запрос о принадлежности элемента данной последовательности</td></tr>
<tr><td>длина</td><td>len</td><td>Запрос количества элементов в последовательности</td></tr>
<tr><td>срез</td><td>[:]</td><td>Выделение части последовательности</td></tr>
</table>

<p>Обратите внимание, что индексы элементов списка начинаются с 0. Операция среза <i>myList[1:3]</i> возвращает список элементов, начинающийся с элемента под индексом 1, но при этом не включает в себя элемент под индексом 3.</p>

<p>Иногда у вас может возникнуть желание проинициализировать список. Этого легко достичь, используя повторения. Например,</p>

<pre>>>> myList = [0] * 6
>>> myList
[0, 0, 0, 0, 0, 0]</pre>

<p>Одно важное отступление, касающееся оператора повторения: его результатом будет последовательность повторений ссылок на объект данных. Это хорошо видно в следующем примере:</p>

<p align="middle"><b>Active Code: 3</b> Повторение ссылок</p>

<p>Переменная <code>А</code> содержит коллекцию из трёх ссылок на оригинальный список <code>myList</code>. Обратите внимание, что изменение одного элемента в <code>myList</code> отражается на всех трёх вхождениях в <code>А</code>.</p>

<p>Списки поддерживают ряд методов, которые будут использоваться для построения структур данных. В <i>таблице 3</i> представлено обобщение методов для работы со списками. Ниже идут примеры их применения.</p>

<table align="middle" border='1'>
<caption>Таблица 3: Методы, предусмотренные для списков в Python</caption>
<thead><td>Название</td><td>Использование</td><td>Пояснение</td></thead>
<tr><td><code>append</code></td><td><code>alist.append(item)</code></td><td>Добавить новый элемент в конец списка</td></tr>
<tr><td><code>insert</code></td><td><code>alist.insert(i,item)</code></td><td>Вставить элемент в i-ую позицию списка</td></tr>
<tr><td><code>pop</code></td><td><code>alist.pop()</code></td><td>Удалить из списка и вернуть последний элемент</td></tr>
<tr><td><code>pop</code></td><td><code>alist.pop(i)</code></td><td>Удалить из списка и вернуть i-й элемент</td></tr>
<tr><td><code>sort</code></td><td><code>alist.sort()</code></td><td>Отсортировать список (изменяет оригинал)</td></tr>
<tr><td><code>reverse</code></td><td><code>alist.reverse()</code></td><td>Изменить список, чтобы элементы шли в обратном порядке</td></tr>
<tr><td><code>del</code></td><td><code>del alist[i]</code></td><td>Удалить элемент на i-й позиции</td></tr>
<tr><td><code>index</code></td><td><code>alist.index(item)</code></td><td>Вернуть индекс первого вхождения <code>item</code></td></tr>
<tr><td><code>count</code></td><td><code>alist.count(item)</code></td><td>Вернуть число вхождений <code>item</code> в список</td></tr>
<tr><td><code>remove</code></td><td><code>alist.remove(item)</code></td><td>Удалить первое вхождения <code>item</code></td></tr>
</table>

<p align="middle"><b>Active Code: 4</b> Примеры методов для списков</p>

<p>Как вы можете видеть, некоторые методы (например, <code>pop</code>) возвращают значение и при этом модифицируют список. Другие (как <code>reverse</code>) просто изменяют список. По умолчанию <code>pop</code> применяется к концу списка, но может также удалять и возвращать конкретное значение. Для всех этих методов индексация по прежнему начинается с нуля. Вы также могли отметить знакомую "dot"-нотацию, запрашивающую у объекта вызов метода.</p>

<p><code>myList.append(False)</code> можно прочитать как "запросить у объекта <code>myList</code> выполнение его метода <code>append</code> и отправить через него значение <code>False</code>". Даже такие простые объекты данных, как целые числа, могут вызывать свои методы подобным образом.</p>

<pre>>>> (54).__add__(21)
75
>>></pre>

<p>В этом фрагменте мы просим объект целочисленного типа <code>54</code> выполнить его метод <code>add</code> (в Python называется <code>__add__</code>), передав в него <code>21</code>, как число, которое нужно прибавить. Результатом будет сумма <code>75</code>. Конечно, обычно мы это пишем как <code>54+21</code>. Подробнее об этих методах мы поговорим чуть позже.</p>

<p>Ещё одной распространённой функцией, часто обсуждаемой в связке со списками, является функция <code>range</code>. Она производит объект "диапазон", представляющий из себя последовательность значений. Используя функцию <code>list</code>, можно представить значение такого объекта в виде списка. Это проиллюстрировано ниже:</p>

<pre>>>> range(10)
range(0, 10)
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> range(5,10)
range(5, 10)
>>> list(range(5,10))
[5, 6, 7, 8, 9]
>>> list(range(5,10,2))
[5, 7, 9]
>>> list(range(10,1,-1))
[10, 9, 8, 7, 6, 5, 4, 3, 2]
>>></pre>

<p>Объект "диапазон" представляет из себя последовательность целых чисел. По умолчанию он начинается с нуля. Если вы предоставите больше параметров, то он будет начинаться и заканчиваться в конкретных точках и сможет даже пропускать некоторые элементы. В нашем первом примере - <code>range(10)</code> - последовательность начинается с 0 и продолжается до 9 (не включая 10). Во втором примере - <code>range(5,10)</code> - начинается с 5 и заканчивается 9 (опять же, не включая 10). <code>range(5,10,2)</code> работает аналогично, но пропускает каждый второй элемент (10 по прежнему не включается).</p>

<p><b>Строки</b> представляют собой коллекции с последовательным доступом из нуля или более букв, чисел и прочих знаков. Мы называем все эти элементы <i>символами</i>. Строковый литерал отличается от идентификатора использованием кавычек (одинарных или двойных).</p>

<pre>>>> "David"
'David'
>>> myName = "David"
>>> myName[3]
'i'
>>> myName*2
'DavidDavid'
>>> len(myName)
5
>>></pre>

<p>Поскольку строки - это последовательности, то все описанные выше операции для последовательностей будут с ними работать так, как ожидается. Дополнительно у строк есть ещё несколько методов, некоторые из которых представлены в <i>таблице 4</i>. Например,</p>

<pre>>>> myName
'David'
>>> myName.upper()
'DAVID'
>>> myName.center(10)
' David '
>>> myName.find('v')
2
>>> myName.split('v')
['Da', 'id']</pre>

<p>Из них очень полезным для обработки данных является метод <code>split</code>. Он принимает строку и возвращает список строк, используя расщепляющий символ как точку разделения. В нашем примере таковым является <code>v</code>. Если разделитель не указан, то <code>split</code> ищет пробельные символы (табуляции, переходы на новую строку и пробелы).</p>

<table align="middle" border='1'>
<caption>Таблица 4: Методы, предусмотренные для строк в Python</caption>
<thead><td>Название</td><td>Использование</td><td>Пояснение</td></thead>
<tr><td><code>center</code></td><td><code>astring.center(w)</code></td><td>Возвращает строку, центрированную в поле размера <code>w</code></td></tr>
<tr><td><code>count</code></td><td><code>astring.count(item)</code></td><td>Возвращает число вхождений <code>item</code> в строку</td></tr>
<tr><td><code>ljust</code></td><td><code>astring.ljust(w)</code></td><td>Возвращает строку с выравниванием по левому краю поля размером <code>w</code></td></tr>
<tr><td><code>lower</code></td><td><code>astring.lower()</code></td><td>Возвращает строку из символов в нижнем регистре</td></tr>
<tr><td><code>rjust</code></td><td><code>astring.rjust(w)</code></td><td>Возвращает строку с выравниванием по правому краю поля размером <code>w</code></td></tr>
<tr><td><code>find</code></td><td><code>astring.find(item)</code></td><td>Возвращает индекс первого вхождения <code>item</code></td></tr>
<tr><td><code>split</code></td><td><code>astring.split(schar)</code></td><td>Разбивает строку на подстроки по символу <code>schar</code></td></tr>
</table>

<p>Основное различие между списками и строками заключается в том, что списки можно изменять, а строки - нет. Это свойство называется <b>мутабельностью</b>. Списки мутабельны, строки иммутабельны. Например, вы легко можете изменить элемент списка, используя индексацию и присваивание. Для строк такие операции не допускаются.</p>

<pre>>>> myList
[1, 3, True, 6.5]
>>> myList[0]=2**10
>>> myList
[1024, 3, True, 6.5]
>>>
>>> myName
'David'
>>> myName[0]='X'

Traceback (most recent call last):
File "<pyshell#84>", line 1, in -toplevel-
myName[0]='X'
TypeError: object doesn't support item assignment
>>></pre>

<p><b>Кортежи</b> очень похожи на списки тем, что также являются гетерогенными последовательностями данных. Различие заключается в иммутабельности кортежей подобно строкам. Они не могут быть изменены. Кортежи записываются как разделённые запятыми значения, заключённые в круглые скобки. Будучи последовательностями, они могут использовать любые операции, описанные выше. Например:</p>

<pre>>>> myTuple = (2,True,4.96)
>>> myTuple
(2, True, 4.96)
>>> len(myTuple)
3
>>> myTuple[0]
2
>>> myTuple * 3
(2, True, 4.96, 2, True, 4.96, 2, True, 4.96)
>>> myTuple[0:2]
(2, True)
>>></pre>

<p>Однако, если вы попытаетесь изменить элемент кортежа, то получите сообщение об ошибке. Обратите внимание, что такое сообщение содержит место и причину возникновения проблемы.</p>

<pre>>>> myTuple[1]=False

Traceback (most recent call last):
File "<pyshell#137>", line 1, in -toplevel-
myTuple[1]=False
TypeError: object doesn't support item assignment
>>></pre>

<p><b>Множеством</b> называется неупорядоченная коллекция из нуля или более неизменяемых объектов данных Python. Множества не допускают дубликатов и записываются как разделённые запятыми значения, заключённые в фигурные скобки. Пустое множество обозначается как <code>set()</code>. Множества гетерогенны и могут присваиваться переменным, как показано ниже.</p>

<pre>>>> {3,6,"cat",4.5,False}
{False, 4.5, 3, 6, 'cat'}
>>> mySet = {3,6,"cat",4.5,False}
>>> mySet
{False, 4.5, 3, 6, 'cat'}
>>></pre>

<p>Не смотря на то, что множества не считаются последовательностями, они поддерживают некоторые знакомые операции из рассмотренных выше. Обзор таких операций представлен в <i>таблице 5</i>, а дальнейший код демонстрирует примеры их использования.</p>

<table align="middle" border='1'>
<caption>Таблица 5: Операции, предусмотренные для множеств в Python</caption>
<thead><td>Название</td><td>Оператор</td><td>Пояснение</td></thead>
<tr><td>Принадлежность</td><td><code>in</code></td><td>Принадлежность множеству</td></tr>
<tr><td>Длина</td><td><code>len</code></td><td>Возвращает количество элементов множества</td></tr>
<tr><td><code>|</code></td><td><code>aset | otherset</code></td><td>Возвращает новое множество, содержащее все элементы обоих множеств</td></tr>
<tr><td><code>&</code></td><td><code>aset & otherset</code></td><td>Возвращает новое множество из элементов, общих для обоих множеств</td></tr>
<tr><td><code>-</code></td><td><code>aset - otherset</code></td><td>Возвращает новое множество из элементов первого множества, не входящих во второе</td></tr>
<tr><td><code><=</code></td><td><code>aset <= otherset</code></td><td>Спрашивает, все ли элементы первого множества входят во второе</td></tr>
</table>

<pre>>>> mySet
{False, 4.5, 3, 6, 'cat'}
>>> len(mySet)
5
>>> False in mySet
True
>>> "dog" in mySet
False
>>></pre>

<p>Множества поддерживают некоторые операции, которые будут знакомы тем, кто работал с ними в математических областях. Обобщение по ним дано в <i>таблице 6</i>, ниже идут примеры. Обратите внимание, что <code>union</code>, <code>intersection</code>, <code>issubset</code> и <code>difference</code> имеют специальные операторы, которые можно использовать вместо них.</p>

<table align="middle" border='1'>
<caption>Таблица 6: Методы, предусмотренные для множеств в Python</caption>
<thead><td>Название</td><td>Использование</td><td>Пояснение</td></thead>
<tr><td><code>union</code></td><td><code>aset.union(otherset)</code></td><td>Возвращает новое множество, состоящее из всех элементов обоих исходных множеств</td></tr>
<tr><td><code>intersection</code></td><td><code>aset.intersection(otherset)</code></td><td>Возвращает новое множество, состоящее только из элементов, общих для обоих исходных множеств</td></tr>
<tr><td><code>difference</code></td><td><code>aset.difference(otherset)</code></td><td>Возвращает новое множество, содержащее все элементы первого множества, не принадлежащие второму</td></tr>
<tr><td><code>issubset</code></td><td><code>aset.issubset(otherset)</code></td><td>Спрашивает, все ли элементы первого множества входят во второе</td></tr>
<tr><td><code>add</code></td><td><code>aset.add(item)</code></td><td>Добавляет новый элемент в множество</td></tr>
<tr><td><code>remove</code></td><td><code>aset.remove(item)</code></td><td>Удаляет элемент из множества</td></tr>
<tr><td><code>pop</code></td><td><code>aset.pop()</code></td><td>Удаляет произвольный элемент из множества</td></tr>
<tr><td><code>clear</code></td><td><code>aset.clear()</code></td><td>Удаляет все элементы из множества</td></tr>
</table>

<pre>>>> mySet
{False, 4.5, 3, 6, 'cat'}
>>> yourSet = {99,3,100}
>>> mySet.union(yourSet)
{False, 4.5, 3, 100, 6, 'cat', 99}
>>> mySet | yourSet
{False, 4.5, 3, 100, 6, 'cat', 99}
>>> mySet.intersection(yourSet)
{3}
>>> mySet & yourSet
{3}
>>> mySet.difference(yourSet)
{False, 4.5, 6, 'cat'}
>>> mySet - yourSet
{False, 4.5, 6, 'cat'}
>>> {3,100}.issubset(yourSet)
True
>>> {3,100}<=yourSet
True
>>> mySet.add("house")
>>> mySet
{False, 4.5, 3, 6, 'house', 'cat'}
>>> mySet.remove(4.5)
>>> mySet
{False, 3, 6, 'house', 'cat'}
>>> mySet.pop()
False
>>> mySet
{3, 6, 'house', 'cat'}
>>> mySet.clear()
>>> mySet
set()
>>></pre>

<p>Заключительной из рассматриваемых нами коллекций Python будет неупорядоченная структура, называемая <b>словарём</b>. Словари - это коллекции ассоциированных пар элементов, каждая из которых состоит из ключа и значения. Эти пары обычно записываются как ключ:значение. Словари выглядят как разделённые запятыми пары ключ:значение, заключённые в фигурные скобки. Например,</p>

<pre>>>> capitals = {'Iowa':'DesMoines','Wisconsin':'Madison'}
>>> capitals
{'Wisconsin': 'Madison', 'Iowa': 'DesMoines'}
>>></pre>

<p>Мы можем манипулировать словарём путём доступа к значению по его ключу или добавляя ещё одну пару ключ-значение. Синтаксис доступа выглядит очень похоже на аналогичный для последовательностей, за исключением того момента, что вместо индекса элемента, мы используем его ключ. Добавление новых элементов тоже похоже.</p>

<p align="middle"><b>Active Code: 5</b> Использование словаря</p>

<p>Тут очень важно обратить внимание, что словари не поддерживают какого-то определённого порядка для своих ключей. Первая добавленная пара <code>('Utah': 'SaltLakeCity')</code> будет помещена на первое место в словаре, вторая <code>('California': 'Sacramento')</code> - на последнее. Размещение ключей зависит от идеи "хеширования", которая более детально будет объясняться в главе 4. Бонусом мы продемонстрировали, что функция для определения длины работает также, как и для предыдущих коллекций.</p>

<p>Словари имеют и методы, и операторы. Они расписаны в <i>таблицах 7</i> и <i>8</i>, а код ниже показывает их в действии. Методы <code>keys</code>, <code>values</code> и <code>items</code> возвращают объекты, содержащие интересующие нас значения. Вы можете использовать функцию <code>list</code>, чтобы конвертировать их в списки. Также показаны два варианта метода <code>get</code>. Если ключ не представлен в словаре, то <code>get</code> вернёт <code>None</code>. Однако, второй (опциональный) параметр может определять другое возвращаемое в этом случае значение.</p>

<table align="middle" border='1'>
<caption>Таблица 7: Операторы, предусмотренные для словарей в Python</caption>
<thead><td>Оператор</td><td>Использование</td><td>Пояснение</td></thead>
<tr><td><code>[]</code></td><td><code>myDict[k]</code></td><td>Возвращает значение, ассоциированное с <code>k</code>, или ошибку, если такового не существует</td></tr>
<tr><td><code>in</code></td><td><code>key in adict</code></td><td>Возвращает <code>True</code>, если значение есть в словаре, <code>False</code> в противном случае</td></tr>
<tr><td><code>del</code></td><td><code>del adict[key]</code></td><td>Удаляет запись из словаря</td></tr>
</table>

<pre>>>> phoneext={'david':1410,'brad':1137}
>>> phoneext
{'brad': 1137, 'david': 1410}
>>> phoneext.keys()
dict_keys(['brad', 'david'])
>>> list(phoneext.keys())
['brad', 'david']
>>> phoneext.values()
dict_values([1137, 1410])
>>> list(phoneext.values())
[1137, 1410]
>>> phoneext.items()
dict_items([('brad', 1137), ('david', 1410)])
>>> list(phoneext.items())
[('brad', 1137), ('david', 1410)]
>>> phoneext.get("kent")
>>> phoneext.get("kent","NO ENTRY")
'NO ENTRY'
>>></pre>

<table align="middle" border='1'>
<caption>Таблица 8: Методы, предусмотренные для словарей в Python</caption>
<thead><td>Название</td><td>Использование</td><td>Пояснение</td></thead>
<tr><td><code>keys</code></td><td><code>adict.keys()</code></td><td>Возвращает ключи словаря как объект dict_keys</td></tr>
<tr><td><code>values</code></td><td><code>adict.values()</code></td><td>Возвращает значения словаря как объект dict_values</td></tr>
<tr><td><code>items</code></td><td><code>adict.items()</code></td><td>Возвращает пары ключ-значение как объект dict_items</td></tr>
<tr><td><code>get</code></td><td><code>adict.get(k)</code></td><td>Возвращает значение, ассоциированное с <code>k</code>, или <code>None</code>, если таковое не найдено</td></tr>
<tr><td><code>get</code></td><td><code>adict.get(k,alt)</code></td><td>Возвращает значение, ассоциированное с <code>k</code>, или <code>alt</code>, если такое не найдено</td></tr>
</table>

<b>Примечание</b>
Данное рабочее пространство предоставлено для вашего удобства. Можете использовать это окно activecode для проб всего, что вам захочется.

<p align="middle"><b>Active Code: 6</b></p>

<h2>Ввод и вывод</h2>

<p>У нас часто возникает необходимость взаимодействовать с пользователями: получать от них данные или предоставлять им какой-либо результат. Большинство программ в наши дни использует диалоговые окна в качестве способа запроса у пользователя каких-либо входных данных. Хотя Python умеет создавать такие окна, мы будем использовать более простой способ. Python предоставляет нам функцию, позволяющую просить пользователя ввести какую-то информацию и возвращать ему ссылку на данные в строковом формате. Эта функция называется <code>input</code>.</p>

<p>Она принимает в качестве своего единственного параметра строку, которую часто называют "<b>приглашением ввода</b>", поскольку она содержит вспомогательную текстовую подсказку для пользователя о том, что ему надо ввести. Например, вы можете вызвать <code>input</code> следующим образом:</p>

<pre>aName = input('Please enter your name: ')</pre>

<p>Теперь, что бы пользователь ни написал после приглашения, оно будет сохранено в переменной <code>aName</code>. Используя функцию ввода, мы легко можем писать инструкции, которые будут подсказывать пользователю какие данные вводить и включать их в дальнейшую обработку. Например, в следующих двух строках в первой у пользователя спрашивается его имя, а вторая печатает результат простейшей обработки полученной строки.</p>

<p align="middle"><b>Active Code: 7</b> Функция input возвращает строку</p>

<p>Очень важно обратить внимание на то, что значение, возвращаемое <code>input</code>, представляет собой строку, состоящую из в точности тех же символов, которые были введены после приглашения. Если вы хотите, чтобы она интерпретировалась как другой тип, то вам следует осуществить явное преобразование типов. В коде ниже строка, введённая пользователем, преобразовывается в число с плавающей запятой, что может быть использовано в дальнейших арифметических вычислениях.</p>

<pre>sradius = input("Please enter the radius of the circle ")
radius = float(sradius)
diameter = 2 * radius</pre>

<h3>Форматирование строки</h3>
<p>Мы уже видели, что функция <code>print</code> предоставляет очень простой способ для вывода значений в программе на Python. Она принимает нуль или более параметров и выводит их, используя пробелы в качестве разделителей по умолчанию. Символ разделителя можно изменить по своему вкусу, установив аргумент <code>sep</code>. Так же каждый вывод <code>print</code> заканчивается автоматическим переходом на новую строку. Это поведение можно изменить, задав аргумент <code>end</code>. Оба этих варианта продемонстрированы в коде ниже:</p>

<pre>>>> print("Hello")
Hello
>>> print("Hello","World")
Hello World
>>> print("Hello","World", sep="***")
Hello***World
>>> print("Hello","World", end="***")
Hello World***>>></pre>

<p>Часто бывает полезно иметь больше способов управления видом вашего вывода. К счастью, Python предоставляет нам альтернативу, называемую "<b>форматированная строка</b>". Она представляет из себя шаблон, содержащий слова и пробелы, остающиеся неизменными, и заменители для переменных, которые будут подставлены в строку. Например, следующий код</p>

<pre>print(aName, "is", age, "years old.")</pre>

<p>содержит слова <code>is</code> и <code>years old</code>, но имя и возраст будут меняться в зависимости от значений переменных во время выполнения программы. Используя форматирование строк, мы можем записать этот код как</p>

<pre>print("%s is %d years old." % (aName, age))</pre>

<p>Этот простой пример наглядно иллюстрирует новой выражение для строк. <code>%</code> является строковым оператором и называется "<b>оператор форматирования</b>". Левая часть выражения содержит шаблон или строку формата, а правая - коллекцию значений, которые будут в неё подставлены. Заметьте, что число значений в правосторонней коллекции равно количеству символов <code>%</code> в строке форматирования. Эти значения будут браться из коллекции по порядку (слева направо) и подставляться в строку форматирования.</p>

<p>Давайте рассмотрим обе части выражения для форматирования более детально. Строка форматирования может содержать один или более спецификаторов преобразования. Символ преобразования говорит оператору форматирования о типе значения, которое будет подставлено в эту позицию. В примере выше <code>%s</code> означает строку, в то время как <code>%d</code> означает целое число. Другие возможные типы спецификаторов включают <code>i</code>, <code>u</code>, <code>f</code>, <code>e</code>, <code>g</code>, <code>c</code> или <code>%</code>. <i>Таблица 9</i> суммирует информацию обо всех возможных видах спецификаторов.</p>

<table align="middle" border='1'>
<caption>Таблица 9: Символы преобразования для строк форматирования</caption>
<thead><td>Символ</td><td>Формат вывода</td></thead>
<tr><td><code>d, i</code></td><td>Целое</td></tr>
<tr><td><code>u</code></td><td>Беззнаковое целое</td></tr>
<tr><td><code>f</code></td><td>Вещественное с плавающей запятой в формате m.ddddd</td></tr>
<tr><td><code>e</code></td><td>Вещественное с плавающей запятой в формате m.ddddde+/-xx</td></tr>
<tr><td><code>E</code></td><td>Вещественное с плавающей запятой в формате m.dddddE+/-xx</td></tr>
<tr><td><code>g</code></td><td>Использует <code>%e</code> для степеней меньше -4 и больше +5. В остальных случаях работает как <code>%f</code></td></tr>
<tr><td><code>c</code></td><td>Одиночный символ</td></tr>
<tr><td><code>s</code></td><td>Строка или любой объект данных Python, который может быть конвертирован в строку с помощью функции <code>str</code></td></tr>
<tr><td><code>%</code></td><td>Вставляет символ %</td></tr>
</table>

<p>В дополнение к символу форматирования вы также можете включать модификатор формата между <code>%</code> и символом форматирования. Модификаторы формата могут использоваться для задания левому или правому краю значения определённой длины. Также их можно использовать, чтобы задать ширину поля вместе с количеством цифр после запятой. <i>Таблица 10</i> объясняет, как это работает.</p>

<table align="middle" border='1'>
<caption>Таблица 10: Дополнительные опции форматирования</caption>
<thead><td>Модификатор</td><td>Пример</td><td>Описание</td></thead>
<tr><td>число</td><td><code>%20d</code></td><td>Помещает значение в поле шириной 20 символов</td></tr>
<tr><td><code>-</code></td><td><code>%-20d</code></td><td>Помещает значение в поле шириной 20 символов выровненным по левому краю</td></tr>
<tr><td><code>+</code></td><td><code>%+20d</code></td><td>Помещает значение в поле шириной 20 символов выровненным по правому краю</td></tr>
<tr><td><code>0</code></td><td><code>%020d</code></td><td>Помещает значение в поле шириной 20 символов, изначально заполненное нулями</td></tr>
<tr><td><code>.</code></td><td><code>%20.2f</code></td><td>Помещает значение в поле шириной 20 символов с двумя символами справа от десятичной точки</td></tr>
<tr><td><code>(name)</code></td><td><code>%(name)d</code></td><td>Берёт значение из прилагаемого словаря, используя <code>name</code> в качестве ключа</td></tr>
</table>

<p>Правая часть оператора форматирования представляет собой коллекцию значений, которые будут подставлены в строку форматирования. Такой коллекцией могут быть кортеж или словарь. Если коллекция - кортеж, то значения вставляются по порядку. Т.е. первый элемент кортежа соответствует первому символу форматирования в строке формата. Если коллекция - словарь, то значения вставляются в соответствии с их ключами. В этом случае все символы форматирования должны использовать модификатор <code>(name)</code>, определяющий имя ключа.</p>

<pre>>>> price = 24
>>> item = "banana"
>>> print("The %s costs %d cents"%(item,price))
The banana costs 24 cents
>>> print("The %+10s costs %5.2f cents"%(item,price))
The banana costs 24.00 cents
>>> print("The %+10s costs %10.2f cents"%(item,price))
The banana costs 24.00 cents
>>> itemdict = {"item":"banana","cost":24}
>>> print("The %(item)s costs %(cost)7.1f cents"%itemdict)
The banana costs 24.0 cents
>>></pre>

<p>В дополнение к строкам форматирования, использующим символы и модификаторы форматирования, тип string в Python также имеет метод <code>format</code>, который может использоваться совместно с новым классом <code>Formatter</code> для реализации сложного строкового форматирования. Больше об этих особенностях вы сможете найти по ссылке на руководство для библиотек Python.</p>

<h2>Управляющие структуры</h2>
<p>Как мы уже отмечали ранее, алгоритмам требуются две важные управляющие структуры: для итераций и для выбора. Обе они поддерживаются в Python в различных формах. Программисты могут выбирать тот способ, который будет более уместным в данных обстоятельствах.</p>

<p>Для итераций Python предлагает стандартный оператор <code>while</code> и очень мощный оператор <code>for</code>. Первый из них повторяет тело кода столько раз, сколько остаётся истинным его условие. Например:</p>

<pre>>>> counter = 1
>>> while counter <= 5:
... print("Hello, world")
... counter = counter + 1


Hello, world
Hello, world
Hello, world
Hello, world
Hello, world</pre>

<p>напечатает фразу "Hello, world" пять раз. Условие оператора <code>while</code> вычисляется каждый раз в начале итерации. Если оно истинно, то будет выполнено тело оператора. Структуру оператора Python <code>while</code> легко увидеть через обязательные шаблоны отступов, которые навязывает этот язык.</p>

<p>Оператор <code>while</code> представляет собой итерационную структуру очень общего назначения, которая может использоваться во многих различных алгоритмах. Очень часто итерации контролирует составное условие. Код</p>

<pre>while counter <= 10 and not done:
...</pre>

<p>приведёт к тому, что тело оператора будет вычисляться только в случае, когда будут выполнены обе части условия. Значение переменной <code>counter</code> должно быть меньше или равно 10, а значение переменной <code>done</code> быть равным <code>False</code> (<code>not False</code> - это <code>True</code>), чтобы результат <code>True and True</code> тоже был истиной.</p>

<p>Несмотря на то, что этот тип конструкции широко используется во многих ситуациях, другая итеративная структура - оператор <code>for</code> - может быть использована в связке со многими коллекциями Python. <code>for</code> можно пользоваться для итерации по членам коллекции, если она является последовательной. Например,</p>

<pre>>>> for item in [1,3,6,2,5]:
... print(item)
...
1
3
6
2
5</pre>

<p>присваивает переменной <code>item</code> каждое последующее значение из списка [1,3,6,2,5], после чего выполняется тело цикла. Этот способ работает для любой последовательной коллекции (списков, кортежей и строк).</p>

<p>Общее применение оператора <code>for</code> заключается в том, чтобы реализовывать определённую итерацию на диапазоне значений. Оператор</p>

<pre>>>> for item in range(5):
... print(item**2)
...
0
1
4
9
16
>>></pre>

<p>выполнит функцию <code>print</code> пять раз. Функция <code>range</code> вернёт диапазон, представляющий собой последовательность 0, 1, 2, 3, 4, и каждое из этих значений будет присвоено переменной <code>item</code>. Затем они будут возведены в квадрат и напечатаны.</p>

<p>Другой очень полезной версией использования этой итерационной структуры является обработка каждого символа строки. Следующий фрагмент кода проходит по списку строк, обрабатывая каждый символ в них присоединением его к списку. Результатом будет список символов из всех слов.</p>

<p align="middle"><b>Active Code: 8</b> Обработка каждого символа строки</p>

<p>Операторы выбора позволяют программистам задавать вопросы и выполнять различные действия, основываясь на результате. Большинство языков программирования предоставляют две версии полезных конструкций: <code>ifelse</code> и <codeif></code>. Простой пример бинарного использования оператора <code>ifelse</code>:</p>

<pre>if n<0:
print("Sorry, value is negative")
else:
print(math.sqrt(n))
</pre>

<p>В этом примере объект, ссылающийся на <code>n</code>, проверяется на условие "меньше нуля". Если это так, то печатается сообщение, что <code>n</code> - отрицательное число. В противном случае выполняется ветка else, в которой вычисляется квадратный корень.</p>

<p>Конструкции выбора, как и любые управляющие конструкции, могут быть вложенными, чтобы результат одного ответа помогал определить, как ответить на следующий. Например, предположим, что <code>score</code> - это переменная, содержащая ссылку на результат теста по информатике.</p>

<pre>if score >= 90:
print('A')
else:
if score >=80:
print('B')
else:
if score >= 70:
print('C')
else:
if score >= 60:
print('D')
else:
print('F')</pre>

<p>Этот фрагмент будет классифицировать значение под названием <code>score</code> с помощью вывода на печать буквы заработанной оценки. Если счёт выше или равен 90, то оператор напечатает <code>А</code>. Если это не так (<code>else</code>), то проверяется следующее условие. Если счёт выше или равен 80, то он должен лежать между 80 и 89, поскольку ответ на предыдущий вопрос был ложью. В этом случае печатается <code>В</code>. Вы можете видеть, как шаблоны отступов в Python помогают ассоциировать <code>if</code> и <code>else</code> без использования дополнительных синтаксических элементов.</p>

<p>Альтернативным синтаксисом для вложенного таким образом выбора является использование ключевого слова <code>elif</code>. <code>else</code> и последующий <code>if</code> комбинируются, исключая таким образом дополнительные уровни. Заметьте, что конечное <code>else</code> по-прежнему необходимо, чтобы предоставить случай по умолчанию, если все остальные условия не выполняться.</p>

<pre>if score >= 90:
print('A')
elif score >=80:
print('B')
elif score >= 70:
print('C')
elif score >= 60:
print('D')
else:
print('F')</pre>

<p>Python также имеет вариант единичной конструкции выбора - оператор <code>if</code>. Для него, если условие истинно, то происходит выполнение действия. В противном случае процесс обработки просто переходит на следующий после <code>if</code> опеатор. Например, в коде ниже сначала проверится, является ли отрицательным значение <code>n</code>. Если это так, то его заменяют абсолютным значением. В любом случае, следующее действие - это извлечение квадратного корня.</p>

<pre>if n<0:
n = abs(n)
print(math.sqrt(n))
</pre>

<b>Самопроверка</b>
<p>Проверьте своё понимание изложенного материала, попробовав решить следующее упражнение. Измените код из Activecode 8 таким образом, чтобы итоговый список содержал только единичные копии каждой буквы</p>

<p align="middle"><b>Active Code: 9</b> Самопроверка</p>

<p>Возвращаясь к спискам, приведём альтернативный метод создания списка с использованием итерационных конструкций и конструкций выбора. Он известен, как <b>генератор списков</b>, и позволяет легко создавать списки, основываясь на неких критериях обработки и выбора. Например, если мы захотим получить список из первых десяти идеальных квадратов, то можем использовать оператор <code>for</code>:</p>

<pre>>>> sqlist=[]
>>> for x in range(1,11):
sqlist.append(x*x)

>>> sqlist
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
>>></pre>

<p>А с использованием генератора списков это делается одной строкой:</p>

<pre>>>> sqlist=[x*x for x in range(1,11)]
>>> sqlist
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
>>></pre>

<p>Переменная <code>x</code> принимает значения от 1 до 10, как это определено для конструкции <code>for</code>. Затем вычисляется величина <code>x*x</code> и присоединяется к создаваемому списку. Общий синтаксис генераторов списков также разрешает использовать критерий выбора, чтобы добавлялись только подходящие элементы. Например,</p>

<pre>>>> sqlist=[x*x for x in range(1,11) if x%2 != 0]
>>> sqlist
[1, 9, 25, 49, 81]
>>></pre>

<p>Этот генератор списков создаёт список, содержащий квадраты только нечётных чисел в диапазоне от 1 до 10. Совместно с генераторами списков можно использовать любые поддерживающие итерации последовательности. Результатом будет новый список.</p>

<pre>>>>[ch.upper() for ch in 'comprehension' if ch not in 'aeiou']
['C', 'M', 'P', 'R', 'H', 'N', 'S', 'N']
>>></pre>

<b>Самопроверка</b>
<p>Проверьте своё понимание генераторов списков, переделав Activecode 8 с их использованием. Дополнительное задание: придумайте, как можно удалить дубликаты.</p>

<p align="middle"><b>Active Code: 10</b> Самопроверка</p>

<h2>Обработка исключений</h2>
<p>Существует два типа ошибок, которые обычно возникают при написании программы. Первый известен как синтаксические ошибки, когда программист ошибается в написании структуры оператора или выражения. Вот пример неправильно написанного оператора и пропущенного двоеточия:</p>

<pre>>>> for i in range(10)
SyntaxError: invalid syntax (<pyshell#61>, line 1)</pre>

<p>В этом случае интерпретатор Python находит, что не может выполнить эту инструкцию до тех пор, пока она не будет удовлетворять языковым правилам. Чаще всего синтаксические ошибки встречаются, когда вы только начинаете изучать новый язык программирования.</p>

<p>Другой тип ошибок, известный как логические ошибки, имеет отношение к тем ситуациям, когда код выполняется, но выдаёт неправильный результат. Причиной может быть ошибка в основном алгоритме или неверная трансляция вами этого алгоритма. В некоторых случаях логические ошибки приводят к очень плохим ситуациям: делению на нуль или попыткам получить доступ к элементу списка, чей индекс выходит за списковые границы. В таком случае логическая ошибка влечёт за собой ошибку времени выполнения, которая вызывает завершение программы. Ошибки такого типа во время выполнения обычно называют <b>исключениями</b>.</p>

<p>Большую часть времени начинающие программисты думают об исключениях, как о фатальных ошибках во время выполнения, приводящих экстренному завершению программы. Однако, большинство языков программирования предоставляют способ иметь дело с такого рода ошибками, что позволяет программисту вмешиваться в процесс, если он того пожелает. Более того, программисты могут создавать свои собственные исключения, если они обнаруживают в программе ситуацию, когда это может быть оправдано.</p>

<p>Когда возникает исключение, мы говорим, что оно "вызывается". Вы можете "обработать" вызванное исключение, используя оператор <code>try</code>. Рассмотрим, например, следующий код, который запрашивает у пользователя целое число, а затем вызывает функцию извлечения квадратного корня из математической библиотеки. Если пользователь вводит значение, которое больше или равно нулю, <code>print</code> выведет квадратный корень. Однако, если пользователь введёт отрицательное значение, то функция квадратного корня сообщит об исключении <code>ValueError</code>.</p>

<pre>>>> anumber = int(input("Please enter an integer "))
Please enter an integer -23
>>> print(math.sqrt(anumber))
Traceback (most recent call last):
File "<pyshell#102>", line 1, in <module>
print(math.sqrt(anumber))
ValueError: math domain error
>>></pre>

<p>Мы можем обработать это исключение, вызвав функцию <code>print</code> внутри <code>try</code> блока. Соответствующий <code>except</code>-блок "поймает" исключение и напечатает сообщение пользователю, в котором сообщит о возникновении исключения. Например:</p>

<pre>>>> try:
print(math.sqrt(anumber))
except:
print("Bad Value for square root")
print("Using absolute value instead")
print(math.sqrt(abs(anumber)))

Bad Value for square root
Using absolute value instead
4.79583152331
>>></pre>

<p>поймает тот факт, что при выполнении <code>sqrt</code> возникло исключение, напечатает сообщение об этом пользователю и возьмёт абсолютное значение аргумента, чтобы быть уверенным в его неотрицательности. Всё вместе это означает, что программа не завершится, а продолжит выполнение следующих операторов.</p>

<p>У программиста также существует возможность искусственно вызвать исключение во время выполнения, используя оператор <code>raise</code>. Например, вместо вызова функции квадратного корня для отрицательного числа, мы прежде можем проверить значение и вызвать наше собственное исключение. Код ниже показывает результат создания нового исключения <code>RuntimeError</code>. Заметьте, что программа по-прежнему будет завершаться, но теперь исключением, вызывающим такое поведение, является нечто явно созданное программистом.</p>

<pre>>>> if anumber < 0:
... raise RuntimeError("You can't use a negative number")
... else:
... print(math.sqrt(anumber))
...
Traceback (most recent call last):
File "<stdin>", line 2, in <module>
RuntimeError: You can't use a negative number
>>></pre>

<p>Существует множество типов исключений кроме показанного выше <code>RuntimeError</code>, которые могут быть вызваны. Смотрите ссылку на руководство по Python, где представлены список всех доступных типов исключений и инструкция по созданию своих собственных.</p>

<h2>Определение функций</h2>
<p>Предыдущим примером вызова процедурной абстракции Python была функция <code>sqrt</code> для вычисления квадратного корня из модуля <code>math</code>. Вообще говоря, мы можем скрывать детали любого вычисления с помощью определения функции. Оно требует её имя, группу параметров и тело. Также функция может явно возвращать значение. Например, простая функция, определённая ниже, возвращает квадрат значения, которое вы в неё помещаете.</p>

<pre>>>> def square(n):
... return n**2
...
>>> square(3)
9
>>> square(square(3))
81
>>></pre>

<p>Синтаксис этого определения функции включает имя (<code>square</code>) и заключённый в скобки список формальных параметров. Для этой функции <code>n</code> - всего лишь формальный параметр, предполагающий, что <code>square</code> необходим только один кусочек данных для её работы. Детали, скрытые "внутри ящика", просто вычисляют результат <code>n**2</code> и возвращают его. Мы можем вызвать функцию <code>square</code>, попросив среду разработки Python вычислить её и поместив внутрь актуальное значение параметра (<code>3</code> в данном случае). Заметьте, что вызов <code>square</code> возвращает целое, которое потом может быть передано другому вызову.</p>

<p>Мы можем реализовать нашу собственную функцию извлечения квадратного корня, используя хорошо известную технологию под названием "метод Ньютона". Этот метод получения приблизительного значения квадратного корня представляет собой итеративное вычисление, сходящееся к правильному значению. Уравнение <code>newguess=(1/2)*(oldguess + n/oldguess)</code> принимает значение <code>n</code> и в цикле угадывает квадратный корень, создавая каждую <code>newguess</code> из <code>oldguess</code>, полученной на предыдущей итерации. Первоначальная догадка равна <code>n/2</code>. <i>Листинг 1</i> демонстрирует определение функции, принимающей значение <code>n</code> и возвращающей его квадратный корень после совершения 20 предположений. Ещё раз, детали метода Ньютона скрыты внутри определения функции, и пользователь ничего не знает о реализации, когда использует функцию по её прямому назначению. <i>Листинг 1</i> также показывает использование символа <code>#</code> как маркера комментария. Любые символы, идущие в строке после <code>#</code>, игнорируются.</p>

<b>Листинг 1</b>
<pre>def squareroot(n):
root = n/2 #initial guess will be 1/2 of n
for k in range(20):
root = (1/2)*(root + (n / root))

return root</pre>

<pre>>>>squareroot(9)
3.0
>>>squareroot(4563)
67.549981495186216
>>></pre>

<b>Самопроверка</b>
<p>Это задание охватывает весь изложенный выше материал. Вы когда-нибудь слышали о теореме о бесконечных обезьянах? В ней утверждается, что если обезьяна будет беспорядочно нажимать на клавиши клавиатуры бесконечное количество времени, то рано или поздно напечатает заданный текст (например, полное собрание сочинений Вильяма Шекспира). Что ж, предположим, что мы заменяем обезьяну функцией на Python. Как вы думаете, сколько она потратит времени на генерирование хотя бы одного предложения из Шекспира? Выберем для проверки фразу “methinks it is like a weasel”.</p>

<p>Вам наверняка не захочется запускать эту программу в браузере, так что запускайте вашу любимую Python IDE. Симуляция будет выполняться с помощью функции, генерирующей строку из двадцати семи символов путём случайного выбора из двадцати шести букв алфавита + пробел. Мы напишем ещё одну функцию, которая будет оценивать каждую сгенерированную строку, сравнивая её с целью.</p>

<p>Третья функция будет циклично вызывать генератор и оценщик до тех пор, пока не совпадёт 100% букв. В случае несовпадения будет генерироваться новая строка целиком. Чтобы было проще следить за прогрессом программы, эта третья функция должна печатать лучшую из уже сгенерированных строк и её оценку каждые тысячу попыток.</p>

<b>Усложнённое задание для самопроверки</b>
<p>Посмотрите, сможете ли вы улучшить программу из самопроверки, сохраняя правильно стоящие буквы и изменяя всего лишь одну из оставшихся, чтобы приблизиться к результату. Алгоритм такого типа относится к классу "поиска с восхождением к вершине", в которых результат сохраняется только в том случае, если он лучше предыдущего.</p>

<h2>Объектно-ориентированное программирование в Python: определение классов</h2>
<p>Мы уже говорили ранее, что Python является объектно-ориентированным языком. До сих пор мы использовали только несколько встроенных классов для демонстрации данных и управляющих структур. Одной из наиболее мощных черт объектно-ориентированного языка программирования является его способность предоставить программисту (решателю задачи) возможность создавать новые классы, моделирующие данные, необходимые для решения проблемы.</p>

<p>Не забывайте: мы используем абстрактные типы данных, чтобы предоставить логическое описание того, как выглядят объекты данных (их состояние) и что они могут делать (их методы). Создавая класс, реализующий абстрактный тип данных, программист пользуется преимуществами абстракции процесса и в то же время предоставляет детали, необходимые при конкретном использовании абстракции в программе. Всякий раз, когда мы хотим реализовать абстрактный тип данных, мы делаем это через новый класс.</p>

<h3>Класс <code>Fraction</code></h3>
<p>Очень распространённым примером для демонстрации деталей реализации пользовательского класса является разработка класса, реализующего абстрактный тип данных <code>Fraction</code>. Мы уже видели, что Python предоставляет в наше пользование несколько числовых классов. Однако, бывают моменты, когда более подходящим является создание объекта данных лишь "выглядящего как" дробь.</p>

<p>Дробь (например, 3/5) состоит из двух частей. Верхнее значение, называемое числитель, может быть любым целым числом. Нижнее значение (знаменатель) - любым целым, большим нуля (отрицательные дроби имеют отрицательный числитель). Также для любой дроби можно создать приближение с плавающей запятой. В этом случае мы хотели бы представлять дробь как точное значение.</p>

<p>Операции для типа <code>Fraction</code> будут позволять объектам данных <code>Fraction</code> вести себя подобно любым другим числовым значениям. Мы должны быть готовы складывать, вычитать, умножать и делить дроби. Мы также хотим иметь возможность показывать дроби в их стандартной "слэш"-форме (например, 3/5). Так же все методы дробей должны возвращать результат в своей сокращённой форме таким образом, чтобы вне зависимости от вида вычислений мы в конце всегда имели бы наиболее общепринятую форму.</p>

<p>В Python мы определяем новый класс предоставлением его имени и набора определений методов, которые синтаксически подобны определениям функций. В этом примере</p>

<pre>class Fraction:

#the methods go here</pre>

<p>нам дан каркас для определения методов. Первым методом, который должны предоставлять все классы, является конструктор. Он определяет способ создания объекта данных. Чтобы создать объект <code>Fraction</code>, нам нужно предоставить два кусочка данных - числитель и знаменатель. В Python метод конструктора всегда называется <code>__init__</code> (по два подчёркивания до и после <code>init</code>). Он демонстрируется в <i>Листинге 2</i>:</p>

<b>Листинг 2</b>
<pre>class Fraction:

def __init__(self,top,bottom):

self.num = top
self.den = bottom</pre>

<p>Обратите внимание, что список формальных параметров содержит три элемента (<code>self</code>, <code>top</code>, <code>bottom</code>). <code>self</code> - это специальный параметр, который всегда используется как обратная ссылка на сам объект. Он всегда должен быть первым формальным параметром, однако, при вызове конструктора в него никогда не передаётся актуальное значение. Как уже было описано ранее, дробям необходимы две части данных состояния - числитель и знаменатель. Нотация <code>self.num</code> конструктора определяет, что объект <code>fraction</code> имеет внутренний объект данных, именуемый <code>num</code>, как часть своего состояния. Аналогично, <code>self.den</code> создаёт знаменатель. Значения этих двух формальных параметров изначально устанавливаются в состояние, позволяющее новому объекту <code>fraction</code> знать своё начальное значение.</p>

<p>Чтобы создать сущность класса <code>Fraction</code>, мы должны вызвать конструктор. Это произойдёт при использовании имени класса с подстановкой актуальных значений в необходимое состояние (заметьте, что мы никогда не вызываем непосредственно <code>__init__</code>). Например,</p>

<pre>myfraction = Fraction(3,5)</pre>

<p>создаст объект с именем <code>myfraction</code>, представляющий дробь <code>3/5</code> (три пятых). <i>Рисунок 5</i> показывает этот объект, как уже существующий.</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/fraction1.png" align="middle"></p>
<p align="middle">Рисунок 5: Экземпляр класса <code>Fraction</code></p>

<p>Следующее, чем мы займёмся, это реализация поведения, требуемого абстрактным классом. Для начала рассмотрим, что происходит, когда мы пытаемся напечатать объект <code>Fraction</code>.</p>

<pre>>>> myf = Fraction(3,5)
>>> print(myf)
<__main__.Fraction instance at 0x409b1acc></pre>

<p>Объект <code>fraction myf</code> не знает, как ему отвечать на запрос о печати. Функция <code>print</code> требует, чтобы объект конвертировал себя самоё в строку, которая будет записана на выходе. Единственный выбор, который имеет <code>myf</code>, - это показать актуальную ссылку, хранящуюся в переменной (непосредственный адрес). Это не то, чего мы хотим.</p>

<p>Существует два пути решения этой проблемы. Первый - определить метод под названием <code>show</code>, который позволит объекту <code>Fraction</code> печать самоё себя как строку. Мы можем реализовать этот метод, как показано в <i>Листинге 3</i>. Если мы будем создавать объект <code>Fraction</code> как и раньше, то мы сможем попросить его показать себя - другими словами, напечатать себя в подходящем формате. К сожалению, в общем случае это не будет работать. Для того, чтобы организовать печать должным образом, нам необходимо сообщить классу <code>Fraction</code>, как ему конвертировать себя в строку. Это то, что необходимо функции <code>print</code> для нормальной работы.</p>

<b>Листинг 3</b>
<pre>def show(self):
print(self.num,"/",self.den)</pre>

<pre>>>> myf = Fraction(3,5)
>>> myf.show()
3 / 5
>>> print(myf)
<__main__.Fraction instance at 0x40bce9ac>
>>></pre>

<p>В Python у всех классов имеется набор стандартных методов, которые предоставляются по умолчанию, но могут не работать должным образом. Один из них, <code>__str__</code>, - это метод преобразования объекта в строку. Реализация по умолчанию для этого метода, как мы уже могли видеть, возвращает строку адреса экземпляра класса. Что нам необходимо сделать, так это предоставить "лучшую" реализацию для него. Мы будем говорить, что эта реализация <b>перегружает</b> предыдущую (или переопределяет поведение метода).</p>

<p>Чтобы сделать это, мы просто определим метод с именем <code>__str__</code> и зададим для него новую реализацию, как показано в <i>Листинге 4</i>. Это определение не нуждается ни в какой дополнительной информации, кроме специального параметра <code>self</code>. В свою очередь, метод будет создавать строковое представление конвертированием каждого кусочка внутренних данных состояния в строку и конкатенацией этих строк с помощью символа <code>/</code> между ними. Результирующая строка будет возвращаться всякий раз, как объект <code>Fraction</code> попросит преобразовать себя в строку. Обратите внимание на различные способы использования этой функции.</p>

<b>Листинг 4</b>
<pre>def __str__(self):
return str(self.num)+"/"+str(self.den)</pre>

<pre>>>> myf = Fraction(3,5)
>>> print(myf)
3/5
>>> print("I ate", myf, "of the pizza")
I ate 3/5 of the pizza
>>> myf.__str__()
'3/5'
>>> str(myf)
'3/5'
>>></pre>

<p>Мы можем перегрузить множество других методов для нашего нового класса <code>Fraction</code>. Одними из наиболее важных из них являются основные арифметические операции. Мы хотели бы иметь возможность создать два объекта <code>Fraction</code>, а затем сложить их вместе, используя стандартную запись "+". На данный момент, складывая две дроби, мы получаем следующее:</p>

<pre>>>> f1 = Fraction(1,4)
>>> f2 = Fraction(1,2)
>>> f1+f2

Traceback (most recent call last):
File "<pyshell#173>", line 1, in -toplevel-
f1+f2
TypeError: unsupported operand type(s) for +:
'instance' and 'instance'
>>></pre>

<p>Если вы внимательнее посмотрите на сообщение об ошибке, то заметите, что загвоздка в том, что оператор "+" не понимает операндов <code>Fraction</code>.</p>

<p>Мы можем исправить это, предоставив классу <code>Fraction</code> метод, перегружающий сложение. В Python такой метод называется <code>__add__</code> и принимает два параметра. Первый (<code>self</code>) необходим всегда, второй представляет из себя второй операнд выражения. Например,</p>

<pre>f1.__add__(f2)</pre>

<p>будет запрашивать у объекта <code>Fraсtion f1</code> прибавить к нему объект <code>Fraction f2</code>. Это может быть записано и в стандартной нотации <code>f1 + f2</code>.</p>

<p>Для того, чтобы сложить две дроби, их нужно привести к общему знаменателю. Простейший способ увериться, что у них одинаковый знаменатель, - это использовать в его качестве произведение знаменателей дробей. Т.е. <code>a/b+c/d=ad/bd+cb/bd=(ad+cb)/bd</code> Реализация показана в <i>Листинге 5</i>. Функция сложения возвращает новый объект <code>Fraction</code> с числителем и знаменателем суммарной дроби. Мы можем использовать этот метод при написании стандартных арифметических выражений с дробями, присваивая результату суммарную дробь и выводя её на экран.</p>

<b>Листинг 5</b>
<pre>def __add__(self,otherfraction):

newnum = self.num*otherfraction.den + self.den*otherfraction.num
newden = self.den * otherfraction.den

return Fraction(newnum,newden)</pre>

<pre>>>> f1=Fraction(1,4)
>>> f2=Fraction(1,2)
>>> f3=f1+f2
>>> print(f3)
6/8
>>></pre>

<p>Метод сложения работает, как мы того и хотели, но одну вещь можно было бы улучшить. Заметьте, что <code>6/8</code> - это правильный результат вычисления <code>(1/4 + 1/2)</code>, но это не сокращённая форма. Лучшим представлением будет <code>3/4</code>. Для того, чтобы быть уверенными, что наш результат всегда имеет сокращённый вид, нам понадобится вспомогательная функция, умеющая сокращать дроби. В ней нужно будет находить наибольший общий делитель, или НОД. Затем мы сможем разделить числитель и знаменатель на НОД, а результат и будет сокращением до наименьших членов.</p>

<p>Наиболее известный алгоритм нахождения наибольшего общего делителя - это алгоритм Евклида, который будет детально обсуждаться в главе 8. Он устанавливает, что наибольшим общим делителем двух чисел <code>m</code> и <code>n</code> будет <code>n</code>, если <code>m</code> делится на <code>n</code> нацело. Однако, если этого не происходит, то ответом будет НОД <code>n</code> и остатка деления <code>m</code> на <code>n</code>. Мы просто предоставим здесь итеративную реализацию этого алгоритма (см. <i>Active Code 11</i>). Обратите внимание, что она работает только при положительном знаменателе. Это допустимо для нашего класса дробей, поскольку мы говорили, что отрицательные дроби будут представляться отрицательным числителем.</p>

<p align="middle"><b>Active Code: 11</b> Функция поиска наибольшего общего делителя</p>

<p>Теперь мы можем использовать эту функцию для сокращения любой дроби. Чтобы представить дробь в сокращённом виде, мы будем делить числитель и знаменатель на их наибольший общий делитель. Итак, для дроби <code>6/8</code> НОД будет равен 2. Разделив верх и низ на 2, мы получим новую дробь <code>3/4</code> (см. <i>Листинг 6</i>).</p>

<b>Листинг 6</b>
<pre>def __add__(self,otherfraction):
newnum = self.num*otherfraction.den + self.den*otherfraction.num
newden = self.den * otherfraction.den
common = gcd(newnum,newden)
return Fraction(newnum//common,newden//common)</pre>

<pre>>>> f1=Fraction(1,4)
>>> f2=Fraction(1,2)
>>> f3=f1+f2
>>> print(f3)
3/4
>>></pre>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/fraction2.png" align="middle"></p>
<p align="middle">Рисунок 6: Экземпляр класса <code>Fraction</code> с двумя методами</p>

<p>Сейчас наш объект <code>Fraction</code> имеет два очень полезных метода и выглядит, как показано на <i>рисунке 6</i>. Группа дополнительных методов, которые нам понадобится включить в класс <code>Fraction</code>, содержит способ сравнивать две дроби. Предположим, что у нас есть два объекта <code>Fraction f1</code> и <code>f2</code>. <code>f1 == f2</code> будет истиной, если они ссылаются на один и тот же объект. Два разных объекта с одинаковыми числителями и знаменателями в этой реализации равны не будут. Это называется <b>поверхностным равенством </b>(см. <i>рисунок 7</i>).</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/fraction3.png" align="middle"></p>
<p align="middle">Рисунок 7: Поверхностное равенство vs глубокое равенство</p>

<p>Мы можем создать <b>глубокое равенство</b> (см. <i>рисунок 7</i>) - по одинаковому значению, а не по одинаковой ссылке - перегрузив метод <code>__eq__</code>. Это ещё один стандартный метод, доступный в любом классе. Он сравнивает два объекта и возвращает <code>True</code>, если их значения равны, или <code>False</code> в противном случае.</p>

<p>В классе <code>Fraction</code> мы можем реализовать метод <code>__eq__</code>, вновь представив обе дроби в виде с одинаковым знаменателем и затем сравнив их числители (см. <i>Листинг 7</i>). Здесь также важно отметить другие операторы отношений, которые могут быть перегружены. Например, метод <code>__le__</code> предоставляет функционал "меньше или равно".</p>

<b>Листинг 7</b>
<pre>def __eq__(self, other):
firstnum = self.num * other.den
secondnum = other.num * self.den

return firstnum == secondnum</pre>

<p>Полностью класс <code>Fraction</code>, реализованный на данный момент, показан в <i>ActiveCode 12</i>. Мы оставляем читателям реализацию оставшейся арифметики и методов отношений в качестве упражнений.</p>

<p align="middle"><b>Active Code: 12</b> Класс <code>Fraction</code></p>

<b>Самопроверка</b>
<p>Чтобы убедиться, что вы понимаете, как в классах Python реализовываются операторы и как корректно писать методы, напишите реализацию операций <code>*</code>, <code>/</code> и <code>-</code>. Также реализуйте операторы сравнения > и < </p>

<p align="middle"><b>Active Code: 13</b></p>

<h3>Наследование: логические вентили и схемы</h3>
<p>Наш финальный раздел будет посвящён другому важному аспекту объектно-ориентированного программирования. <b>Наследование</b> - это способность одного класса быть связанным с другим классом подобно тому, как бывают связаны между собой люди. Дети наследуют черты своих родителей. Аналогично, в Python класс-потомок наследует характеристики данных и поведения от класса-предка. Такие классы часто называют <b>субклассами</b> и <b>суперклассами</b>, соответственно.</p>

<p><i>Рисунок 8</i> показывает встроенные коллекции Python и взаимоотношения между ними. Такого рода структуру отношений называют <b>иерархией наследования</b>. Например, список является потомком коллекций с последовательным доступом. В данном случае мы назовём список "наследником", а коллекцию - "родителем" (или список - субклассом, коллекцию - суперклассом). Такая зависимость часто называется <code>отношением IS-A</code> (список является (is a) коллекцией с последовательным доступом). Это подразумевает, что списки наследуют важнейшие характеристики коллекций, в частности - упорядочение исходных данных, и такие операции, как конкатенация, повторение и индексация.</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/inheritance1.png" align="middle"></p>
<p align="middle">Рисунок 8: Иерархия наследования для коллекций Python</p>

<p>И списки, и кортежи, и строки представляют из себя коллекции с последовательным доступом, наследуя общую организацию данных и операции. Однако, они различны по гомогенности данных и мутабельности наборов. Все потомки наследуют своим родителям, но различаются между собой включением дополнительных характеристик.</p>

<p>Организовывая классы в иерархическом порядке, объектно-ориентированные языки программирования позволяют расширять ранее написанный код под вновь возникающие потребности. В дополнение, организовывая данные в иерархической манере, мы лучше понимаем существующие между ними взаимоотношения. Мы можем создавать более эффективное абстрактное представление.</p>

<p>Чтобы глубже исследовать эту идею, мы сделаем <b>симуляцию</b> - приложение, симулирующее цифровые цепи. Её основными строительными блоками будут логические элементы. Эти электронные переключатели представляют собой соотношения булевой алгебры между их входом и выходом. В общем случае вентили имеют единственную линию выхода. Значение на ней зависит от значений, подаваемых на входные линии.</p>

<p>Вентиль "И" имеет два входа, на каждый из которых может подаваться нуль или единица (кодирование <code>False</code> или <code>True</code>, соответственно). Если на оба входа подана единица, то значение на выходе тоже 1. Однако, если хотя бы один из входов установлен в нуль, то результатом будет 0. Вентиль "ИЛИ" также имеет два входа и выдаёт единицу, если хотя бы на одном из них 1. В случае, когда обе входные линии в нуле, результат тоже 0.</p>

<p>Вентиль "НЕ" отличается от предыдущих тем, что имеет всего один вход. Значение на выходе будет просто обратным входному значению. Т.е., если на входе 0, то на выходе 1, и наоборот. <i>Рисунок 9</i> показывает, как обычно представляют каждый из этих вентилей. Так же каждый из них имеет свою <b>таблицу истинности</b> значений, отражающую отображение вентилем входа на выход.</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/truthtable.png" align="middle"></p>
<p align="middle">Рисунок 9: Три типа логических элементов</p>

<p>Комбинируя эти вентили в различные структуры и применяя к получившемуся наборы входных комбинаций, мы можем строить цепи, обладающие различными логическими функциями. <i>Рисунок 10</i> демонстрирует цепь, состоящую из двух вентилей "И", одного вентиля "ИЛИ" и одного вентиля "НЕ". Выходы элементов "И" подключены непосредственно к входам элемента "ИЛИ", а его результирующий вывод - ко входу вентиля "НЕ". Если мы будем подавать набор входных значений на четыре входные линии (по две на каждый элемент "И"), то они будут обработаны, и результат появится на выходе вентиля "НЕ". <i>Рисунок 10</i> так же демонстрирует пример со значениями.</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/circuit1.png" align="middle"></p>
<p align="middle">Рисунок 10: Цепь</p>

<p>задавшись целью воплотить эту цепь, мы прежде всего должны создать представление для логических вентилей. Их легко организовать, как класс с наследственной иерархией, показанной на <i>рисунке 11</i>. Верхний класс <code>LogicGate</code> представляет наиболее общие характеристики логических элементов: в частности, метку вентиля и линию выхода. Следующий уровень субклассов разбивает логические элементы на два семейства: имеющие один вход и имеющие два входа. Ниже уже появляются конкретные логические функции для каждого вентиля.</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/gates.png" align="middle"></p>
<p align="middle">Рисунок 11: Иерархия наследования для логических элементов</p>

<p>Теперь мы можем заняться реализацией классов, начиная с наиболее общего - <code>LogicGate</code>. Как уже отмечалось ранее, каждый вентиль имеет метку для идентификации и единственную линию выхода. В дополнение, нам потребуются методы, позволяющие пользователю запрашивать у вентиля его метку.</p>

<p>Следующим аспектом поведения, в котором нуждается любой вентиль, является необходимость знать его выходное значение. Это требуется для выполнения вентилями соответствующих алгоритмов, основанных на текущих значениях на входах. Для генерации выходного значения логическим элементам необходимо конкретное знание логики их работы. Это подразумевает вызов метода, совершающего логические вычисления. Полностью класс показан в <i>Листинге 8</i>.</p>

<b>Листинг 8</b>
<pre>class LogicGate:

def __init__(self,n):
self.label = n
self.output = None

def getLabel(self):
return self.label

def getOutput(self):
self.output = self.performGateLogic()
return self.output</pre>

<p>На данный момент мы не будем реализовывать функцию <code>performGateLogic</code>. Причина в том, что мы не знаем, как будут работать логические операции у каждого вентиля. Эти детали мы включим для каждого добавленного в иерархию элемента индивидуально. Это очень мощная идея объектно-ориентированного программирования: мы пишем метод, который будет использовать ещё не существующий код. Параметр <code>self</code> является ссылкой на актуальный вентиль, вызывающий метод. Любые вновь добавленные в иерархию логические элементы просто будут нуждаться в собственной реализации функции <code>performGateLogic</code>, которая будет использована в нужный момент. После этого вентили будут предоставлять своё выходное значение. Эта возможность расширять существующую иерархию и обеспечивать необходимые для её нового класса функции чрезвычайно важна для повторного использования существующего кода.</p>

<p>Мы разделили логические элементы, основываясь на количестве их входных линий. У вентиля "И" их две, вентиля "ИЛИ" тоже две, а у вентиля "НЕ" - одна. Класс <code>BinaryGate</code> будет субклассом <code>LogicGate</code> и включит в себя элементы с двумя входными линиями. Класс <code>UnaryGate</code> также будет субклассом <code>LogicGate</code>, но входная линия у его элементов будет одна. В конструировании компьютерных цепей такие линии иногда называют "пинами", так что мы будем использовать эту терминологию и в нашей реализации.</p>

<b>Листинг 9</b>
<pre>class BinaryGate(LogicGate):

def __init__(self,n):
LogicGate.__init__(self,n)

self.pinA = None
self.pinB = None

def getPinA(self):
return int(input("Enter Pin A input for gate "+ self.getLabel()+"-->"))

def getPinB(self):
return int(input("Enter Pin B input for gate "+ self.getLabel()+"-->"))</pre>

<b>Листинг 10</b>
<pre>class UnaryGate(LogicGate):

def __init__(self,n):
LogicGate.__init__(self,n)

self.pin = None

def getPin(self):
return int(input("Enter Pin input for gate "+ self.getLabel()+"-->"))</pre>

<p><i>Листинг 9</i> и <i>Листинг 10</i> реализуют эти два класса. Конструкторы их обоих начинаются с явного вызова конструктора родительского класса с использованием функции <code>super</code>. Когда мы создаём экземпляр класса <code>BinaryGate</code>, мы прежде всего хотим инициализировать любые элементы данных, которые наследуются от <code>LogicGate</code>. В данном случае это метка вентиля. Затем конструктор добавляет два входа (<code>pinA</code> и <code>pinB</code>). Это очень распространённая схема, которую вам следует использовать при проектировании иерархии классов. Конструктору дочернего класса сначала нужно вызвать конструктор родительского класса, и только потом переключаться на собственные, отличные от предка, данные.</p>

<p>Единственным, что добавится к поведению класса <code>BinaryGate</code> будет возможность получать значения от двух входных линий. Поскольку эти значения берутся откуда-то извне, то с помощью оператора ввода мы можем просто попросить пользователя предоставить их. То же самое происходит в реализации класса <code>UnaryGate</code>, за исключением того момента, что он имеет всего один вход.</p>

<p>Теперь, когда у нас есть общие классы для вентилей, зависящие от количества их входов, мы можем создавать специфические вентили с уникальным поведением. Например, класс <code>AndGate</code>, который будет подклассом <code>BinaryGate</code>, поскольку элемент "И" имеет два входа. Как и раньше, первая строка конструктора вызывает конструктор базового класса (<code>BinaryGate</code>), который, в свою очередь, вызывает конструктор своего родителя (<code>LogicGate</code>). Обратите внимание, что класс <code>AndGate</code> не предоставляет каких-либо новых дополнительных данных, поскольку наследует две входные линии, одну выходную и метку.</p>

<b>Листинг 11</b>
<pre>class AndGate(BinaryGate):

def __init__(self,n):
BinaryGate.__init__(self,n)

def performGateLogic(self):

a = self.getPinA()
b = self.getPinB()
if a==1 and b==1:
return 1
else:
return 0</pre>

<p>Единственная вещь, которую необходимо добавить в <code>AndGate</code>, - это специфическое поведение при выполнении булевых операций, которое мы описывали выше. Это то место, где мы можем предоставить метод <code>performGateLogic</code>. Для вентиля "И" он сначала должен получить два входных значения и вернуть 1, если оба они равны единице. Полностью данный класс показан в <i>Листинге 11</i>.</p>

<p>Мы можем продемонстрировать работу класса <code>AndGate</code>, создав его сущность и попросив её вычислить её выходное значение. Следующий код показывает <code>AndGate</code> объект <code>g1</code>, который имеет внутреннюю метку <code>"G1"</code>. Когда мы вызываем метод <code>getOutput</code>, объект сначала должен вызвать свой метод <code>performGateLogic</code>, который, в свою очередь, запрашивает значения из двух входных линий. После того, как требуемые данные получены, показывается правильное выходное значение.</p>

<pre>>>> g1 = AndGate("G1")
>>> g1.getOutput()
Enter Pin A input for gate G1-->1
Enter Pin B input for gate G1-->0
0</pre>

<p>Такая же работа должна быть проведена для элементов "ИЛИ" и "НЕ". Класс <code>OrGate</code> также будет субклассом <code>BinaryGate</code>, а класс <code>NotGate</code> расширит <code>UnaryGate</code>. Оба они будут нуждаться в собственной реализации функции <code>performGateLogic</code> со специфическим поведением.</p>

<p>Мы можем использовать единичный логический элемент, сконструировав в начале экземпляр одного из классов вентилей и затем запросив его выходное значение (что, в свою очередь, потребует предоставления входных данных). Например,</p>

<pre>>>> g2 = OrGate("G2")
>>> g2.getOutput()
Enter Pin A input for gate G2-->1
Enter Pin B input for gate G2-->1
1
>>> g2.getOutput()
Enter Pin A input for gate G2-->0
Enter Pin B input for gate G2-->0
0
>>> g3 = NotGate("G3")
>>> g3.getOutput()
Enter Pin input for gate G3-->0
1</pre>

<p>Теперь, когда у нас есть работающие базовые вентили, мы можем вернуться к построению цепей. Чтобы создать цепь, нам необходимо соединить вентили вместе: выход одного ко входу другого. Для мы реализуем новый класс под названием <code>Connector</code>.</p>

<p>Класс <code>Connector</code> не будет принадлежать иерархии логических элементов. Однако, он будет использовать её, поскольку каждый соединитель имеет два вентиля - по одному на каждый конец (см. <i>рисунок 12</i>). Отношения такого рода очень важны в объектно-ориентированном программировании. Они называются <b>отношениями "HAS-A"</b>. Напомним, что ранее мы использовали словосочетание "IS-A отношение", чтобы показать, как дочерний класс относится к родительскому. Например, <code>UnaryGate</code> является (IS-A) <code>LogicGate</code>.</p>

<p align="middle"><img src="http://interactivepython.org/runestone/static/pythonds/_images/connector.png" align="middle"></p>
<p align="middle">Рисунок 12: Connector соединяет выход одного вентиля со входом другого.</p>

<p>Теперь, для класса <code>Connector</code>, мы скажем, что он имеет <code>LogicGate</code>, подразумевая, что соединители имеют внутри экземпляры <code>LogicGate</code>, но не являются частью иерархии. При конструировании классов очень важно различать те из них, которые имеют отношения "IS-A" (что требует наследования), и те, которые обладают отношениями "HAS-A" (без наследования).</p>

<p><i>Листинг 12</i> демонстрирует класс <code>Connector</code>. Два экземпляра вентилей внутри каждого объекта соединителя будут обозначаться как <code>fromgate</code> и <code>topgate</code>, различая таким образом, что данные будут "течь" от выхода одного вентиля ко входу другого. Вызов <code>setNextPin</code> очень важен при создании соединителей (см. <i>Листинг 13</i>). Нам необходимо добавить этот метод к нашим классам для вентилей таким образом, чтобы каждый <code>togate</code> мог выбрать подходящую входную линию для соединения.</p>

<b>Листинг 12</b>
<pre>class Connector:

def __init__(self, fgate, tgate):
self.fromgate = fgate
self.togate = tgate

tgate.setNextPin(self)

def getFrom(self):
return self.fromgate

def getTo(self):
return self.togate</pre>

<p>В классе <code>BinaryGate</code> для вентилей с двумя возможными входными линиями коннектор должен присоединяться только к одной из них. Если доступны обе, то по умолчанию мы будем выбирать <code>pinA</code>. Если он уже подсоединён к чему-либо, то выберем <code>pinB</code>. Подсоединиться к вентилю, не имеющему доступных входов, невозможно.</p>

<b>Листинг 13</b>
<pre>def setNextPin(self,source):
if self.pinA == None:
self.pinA = source
else:
if self.pinB == None:
self.pinB = source
else:
raise RuntimeError("Error: NO EMPTY PINS")</pre>

<p>Теперь можно получать входные данные двумя способами: извне, как раньше, и с выхода вентиля, присоединённого ко входу данного. Это требование меняет методы <code>getPinA</code> и <code>getPinB</code> (см. <i>Листинг 14</i>). Если входная линия ни к чему не подсоединена (<code>None</code>), то, как и раньше, будет задаваться вопрос пользователю. Однако, если она связана, то подключение осуществится, затребовав значение выхода <code>fromgate</code>. В свою очередь, это запускает логическую обработку вентилем поступивших данных. Процесс продолжается, пока есть доступные входы, и окончательное выходное значение становится требуемым входом для вентиля в вопросе. В каком-то смысле, схема работает в обратную сторону, чтобы найти входные данные, необходимые для производства конечного результата.</p>

<b>Листинг 14</b>
<pre>def getPinA(self):
if self.pinA == None:
return input("Enter Pin A input for gate " + self.getName()+"-->")
else:
return self.pinA.getFrom().getOutput()</pre>

<p>Следующий фрагмент конструирует схему, ранее показанную в этом разделе:</p>

<pre>>>> g1 = AndGate("G1")
>>> g2 = AndGate("G2")
>>> g3 = OrGate("G3")
>>> g4 = NotGate("G4")
>>> c1 = Connector(g1,g3)
>>> c2 = Connector(g2,g3)
>>> c3 = Connector(g3,g4)</pre>

<p>Выходы двух вентилей "И" (<code>g1</code> и <code>g2</code>) соединены с вентилем "ИЛИ" (<code>g3</code>), а его выход - с вентилем "НЕ" (<code>g4</code>). Выход вентиля "НЕ" - это выход схемы целиком. Пример работы:</p>

<pre>>>> g4.getOutput()
Pin A input for gate G1-->0
Pin B input for gate G1-->1
Pin A input for gate G2-->1
Pin B input for gate G2-->1
0</pre>

<p>Попробуйте сами, используя ActiveCode 14.</p>

<p align="middle"><b>Active Code: 14</b> Законченная программа для построения цепей</code></p>

<b>Самопроверка</b>
<p>Создайте два новых класса вентилей: <code>NorGate</code> и <code>NandGate</code>. Первый работает подобно <code>OrGate</code>, к выходу которого подключено НЕ. Второй - как <code>AndGate</code> с НЕ на выходе</p>

<p>Создайте ряд из вентилей, который доказывал бы, что NOT (( A and B) or (C and D)) это то же самое, что и NOT( A and B ) and NOT (C and D). Убедитесь, что используете в этой симуляции некоторые из вновь созданных вами вентилей.</p>

<p align="middle"><b>Active Code: 15</b></code></p>

<h1>Заключение</h1>
<ul>
<li>Информатика - это наука о решении задач.</li>
<li>Информатика использует абстракции, как инструмент для представления и процессов, и данных.</li>
<li>Абстрактные типы данных позволяют программистам управлять сложностью предметной области задачи путём сокрытия деталей реализации данных.</li>
<li>Python - мощный объектно-ориентированный язык с низким порогом вхождения.</li>
<li>Списки, кортежи и строки созданы в Python как упорядоченные коллекции.</li>
<li>Словари и множества - неупорядоченные коллекции данных.</li>
<li>Классы позволяют программистам реализовывать абстрактные типы данных.</li>
<li>Программисты могут перегружать стандартные методы или создавать свои собственные.</li>
<li>Классы можно организовывать в иерархии.</li>
<li>Конструктор класса всегда должен вызывать конструктор своего предка до того, как продолжать работать со своими собственными данными и поведением.</li>
<li></li>
</ul>

<h1>Ключевые термины</h1>
<table>
<tr><td>абстрактный тип данных</td><td>абстракция</td><td>алгоритм</td></tr>
<tr><td>абстракция данных</td><td>вычислимый</td><td>генераторы списков</td></tr>
<tr><td>глубокая эквивалентность</td><td></td><td></td></tr>
<tr><td>инкапсуляция</td><td>исключение</td><td>иерархия наследования</td></tr>
<tr><td>интерфейс</td><td>класс</td><td>метод</td></tr>
<tr><td>мутабельность</td><td>наследование</td><td>независимая реализация</td></tr>
<tr><td>отношение "IS-A"</td><td>отношение "HAS-A"</td><td>объект</td></tr>
<tr><td>оператор форматирования</td><td>поверхностная эквивалентность</td><td>программирование</td></tr>
<tr><td>приглашение ввода</td><td>процедурная абстракция</td><td>симуляция</td></tr>
<tr><td>скрытие информации</td><td>список</td><td>словарь</td></tr>
<tr><td>структура данных</td><td>строка</td><td>субкласс</td></tr>
<tr><td>суперкласс</td><td>тип данных</td><td>таблица истинности</td></tr>
<tr><td>форматированные строки</td><td><code>self</code></td><td></td></tr>
</table>

<h1>Вопросы для обсуждения</h1>
<ol>
<li>Создайте иерархию классов для людей в кампусе колледжа. Включите в неё руководство факультетом, преподавателей и студентов. Что между ними общего? Чем они отличаются друг от друга?</li>
<li>Создайте иерархию классов для банковских аккаунтов.</li>
<li>Создайте иерархию классов для различных типов компьютеров.</li>
<li>Используя представленные в главе классы, интерактивно создайте цепь и протестируйте её.</li>
</ol>

<h1>Упражнения</h1>
<ol>
<li>Реализуйте простые методы <code>getNum</code> и <code>getDen</code>, возвращающие числитель и знаменатель дроби.</li>
<li>Во многих отношениях было бы лучше, если бы все дроби приводились в сокращённом виде с самого начала. Измените конструктор класса <code>Fraction</code> таким образом, чтобы GCD использовался для сокращения дробей немедленно. Заметьте - это означает, что функция <code>__add__</code> больше не нуждается в сокращениях. Произведите необходимые модификации.</li>
<li>Реализуйте оставшиеся простые арифметические операторы (<code>__sub__</code>, <code>__mul__</code> и <code>__truediv__)</code>.</li>
<li>Реализуйте оставшиеся операторы отношений (<code>__gt__</code>, <code>__ge__</code>, <code>__lt__</code> и <code>__ne__</code>).</li>
<li>Модифицируйте конструктор класса дробей таким образом, чтобы он поверял, являются ли числитель и знаменатель целыми числами. Если хотя бы одно из условий не выполняется, то вызовите исключение.</li>
<li>В определении дробей мы предположили, что отрицательные дроби имеют отрицательный числитель и положительный знаменатель. Использование отрицательного знаменателя может повлечь за собой неправильные результаты некоторых операторов отношений. Вообще, это ограничение является не таким уж необходимым. Модифицируйте конструктор таким образом, чтобы позволить пользователю вводить отрицательный знаменатель, а все операторы продолжили работать правильным образом.</li>
<li>Исследуйте метод <code>__radd__</code>. В чём его отличие от <code>__add__</code>? Когда он используется? Реализуйте <code>__radd__</code>.</li>
<li>Задание аналогично предыдущему, но на этот раз рассмотрите <code>__iadd__</code> метод.</li>
<li>Исследуйте <code>__repr__</code> метод. Чем он отличается от <code>__str__</code>? Когда используется? Реализуйте <code>__repr__</code>.</li>
<li>Исследуйте другие типы существующих вентилей (таких как НЕ-И, НЕ-ИЛИ и исключающее ИЛИ). Добавьте их в иерархию цепей. Сколько дополнительного кода вам понадобилось?</li>
<li>Наиболее простая арифметическая цепь называется полусумматор. Исследуйте и реализуйте её.</li>
<li>Теперь расширьте эту цепь и реализуйте 8-битный полный сумматор.</li>
<li>Симуляция цепи, показанная в данной части, работает в обратном направлении. Другими словами, выходное значение производится путём обратной работы через входные значения, которые в свою очередь запрашивают другие выходы. Это продолжается до тех пор, пока не будут найдены внешние входные линии. В этот момент у пользователя будут запрошены значения для них. Измените реализацию таким образом, чтобы эти действия происходили в прямом направлении: схема производила выход после получения значений на входах.</li>
<li>Создайте класс, представляющий игровые карты. Потом создайте класс, представляющий колоду карт. Используя эти два класса, реализуйте вашу любимую карточную игру.</li>
<li>Найдите головоломку Судоку в местной газете. Напишите программу для её решения.</li>
</ol>
