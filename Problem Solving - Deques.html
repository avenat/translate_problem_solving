Мы завершаем введение в основные структуры данных рассмотрением ещё одного варианта линейных коллекций. Однако, в отличие от стеков и очередей, дек имеет очень мало ограничений.

## Что такое дек?


**Дек**, также называемый двусторонней очередью, - это упорядоченная коллекция элементов, подобная очереди. Он имеет два конца (голову и хвост), и его элементы остаются позиционированными. Что отличает дек, так это нестрогая природа добавления и удаления составляющих. Новые элементы могут быть добавлены как в голову, так и в хвост. Аналогично, существующие компоненты также могут удаляться из обоих концов. В каком-то смысле, этот гибрид линейной структуры предоставляет все возможности стеков и очередей в единой структуре данных. *Рисунок 1* демонстрирует дек из объектов данных Python.


Важно отметить, что несмотря на обладание деком многих характеристик стеков и очередей, он не поддерживает LIFO или FIFO упорядочение, которые воплощаются в жизнь этими структурами данных. Только от вас зависит, какого типа операции добавления или удаления использовать.


![Рисунок 1](http://interactivepython.org/courselib/static/pythonds/_images/basicdeque.png "Рисунок 1: Дек из объектов данных Python")


## Абстрактный тип данных "дек"


Абстрактный тип данных дека определяется следующими структурой и операциями. Как было описано выше, дек имеет структуру упорядоченной коллекции элементов, которые могут добавляться и удаляться с любого конца - и с головы, и с хвоста. Операции для дека представлены ниже:


* ```Deque()``` создаёт новый пустой дек. Не нуждается в параметрах и возвращает пустой дек.
* ```addFront(item)``` добавляет новый элемент в голову дека. Параметр (элемент) необходим, ничего не возвращает.
* ```addRear(item)``` добавляет новый элемент в хвост дека. Параметр (элемент) необходим, ничего не возвращает.
* ```removeFront()``` удаляет первый элемент из дека. Не нуждается в параметрах и возвращает элемент. Дек модифицируется.
* ```removeRear()``` удаляет последний элемент из дека. Не нуждается в параметрах и возвращает элемент. Дек модифицируется.
* ```isEmpty()``` проверяет дек на пустоту. Не нуждается в параметрах и возвращает булево значение.
* ```size()``` возвращает количество элементов в деке. Не нуждается в параметрах и возвращает целое.


В качестве примера, если мы предположим, что ```d``` - это дек, который был создан и всё ещё пуст, то *таблица 1* демонстрирует результаты серии операций над ним. Обратите внимание, что содержимое головы располагается справа. Очень важно отслеживать, где голова, а где хвост дека, когда вы перемещаете элементы в и из коллекции, поскольку эти вещи могут быть несколько запутанными.

<table border="1">
  <caption><b>Таблица 1: Пример операций для дека</b></caption>
  <tr>
    <td><b>Операция</b></td><td><b>Содержимое дека</b></td><td><b>Возвращаемое значение</b></td>
  </tr>
  <tr>
    <td><code>d.isEmpty()</code></td><td><code>[]</code></td><td><code>True</code></td>
  </tr>
  <tr>
    <td><code>d.addRear(4)</code></td><td><code>[4]</code></td><td><code></code></td>
  </tr>
  <tr>
    <td><code>d.addRear('dog')</code></td><td><code>['dog',4,]</code></td><td><code></code></td>
  </tr>
  <tr>
    <td><code>d.addFront('cat')</code></td><td><code>['dog',4,'cat']</code></td><td><code></code></td>
  </tr>
  <tr>
    <td><code>d.addFront(True)</code></td><td><code>['dog',4,'cat',True]</code></td><td><code></code></td>
  </tr>
  <tr>
    <td><code>d.size()</code></td><td><code>['dog',4,'cat',True]</code></td><td><code>4</code></td>
  </tr>
  <tr>
    <td><code>d.isEmpty()</code></td><td><code>['dog',4,'cat',True]</code></td><td><code>False</code></td>
  </tr>
  <tr>
    <td><code>d.addRear(8.4)</code></td><td><code>[8.4,'dog',4,'cat',True]</code></td><td><code></code></td>
  </tr>
  <tr>
    <td><code>d.removeRear()</code></td><td><code>['dog',4,'cat',True]</code></td><td><code>8.4</code></td>
  </tr>
  <tr>
    <td><code>d.removeFront()</code></td><td><code>['dog',4,'cat']</code></td><td><code>True</code></td>
  </tr>
  </table>



## Реализация дека в Python


 Создадим новый класс для реализации абстрактного типа данных "дек", как мы неоднократно делали в предыдущих разделах. Список Python вновь предоставит очень хороший набор методов, с помощью которых мы построим детализацию дека. Наша реализация (*листинг 1*) будет предполагать, что хвост дека находится в нулевой позиции списка.


  **Листинг 1**


```python
  class Deque:
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def addFront(self, item):
        self.items.append(item)
    def addRear(self, item):
        self.items.insert(0,item)
    def removeFront(self):
        return self.items.pop()
    def removeRear(self):
        return self.items.pop(0)
    def size(self):
        return len(self.items)
```


  В ```removeFront``` мы используем метод ```pop``` для удаления последнего элемента из списка. Однако, в ```removeRear``` метод ```pop(0)``` должен удалять первый из них. Также нам нужно использовать метод ```insert``` (строка 12) в ```addRear```, поскольку ```append``` предполагает добавление нового элемента в конец списка.

  CodeLens 1 демонстрирует класс ```Deque``` в последовательности действий, которую мы представили в *таблице 1*.


  **CodeLens: 1 Пример операций над деком**


  Вы можете увидеть много сходства в коде на Python, описывающем стеки и очереди. Вы также, вероятно, заметили, что в этой реализации добавление и удаление элементов из головы имеет O(1), в то время как те же операции для хвоста - O(n). Это и следовало ожидать, учитывая какие распространённые методы использовались для этой цели. Опять же, главное, в чём мы должны быть уверены, - так это в том, что в нашей реализации назначено хвостом, а что головой дека.


## Проверка палиндрома


  Интересная задача, которая может быть легко решена с использованием структуры данных "дек" - это классическая задача палиндрома. **Палиндромом** называют строку, которая одинаково читается справа налево и слева направо. Например, *radar*, *toot* или *madam*. Мы хотим создать алгоритм, принимающий на вход строку символов и проверяющий, является ли она палиндромом.


  Для решения данной задачи мы будем использовать дек в качестве хранилища строковых символов. Мы будем обрабатывать строку слева направо и добавлять каждый её элемент в хвост дека. В этот момент он будет работать очень схоже с обычной очередью. Однако, теперь мы можем использовать дуальную функциональность дека. Его голова будет хранить первый символ строки, а хвост - последний (см. *рисунок 2*).


  ![Рисунок 2](http://interactivepython.org/courselib/static/pythonds/_images/palindromesetup.png "Рисунок 2: Дек")


  Поскольку мы способны удалять оба элемента сразу, то можно производить сравнение и продолжать только в случае, если символы совпадают. Если соответствие первого и последнего элементов будет сохраняться, то в конечном итоге мы придём или к отсутствию символов, или останемся с деком размером 1 - в зависимости от того, была ли длина исходной строки чётным или нечётным числом. Но обоих случаях входная последовательность будет палиндромом. Полностью функция проверки представлена в *ActiveCode 1*.


  **ActiveCode: 1 Проверка палиндрома с использованием дека**
